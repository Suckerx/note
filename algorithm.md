## 认识复杂度和简单排序算法

![1666078028807](algorithm.assets/1666078028807.png)

**冒泡排序：**

比较0 和 1 位置上的数大小，然后交换，然后比较1 和 2 位置上的数交换，依次类推，第二遍从1 开始，1 和 2 比较后交换

![1666081093445](algorithm.assets/1666081093445.png)

因此是等差数列，时间复杂度为O(n^2)

![1666081184424](algorithm.assets/1666081184424.png)

代码：

![1666081288048](algorithm.assets/1666081288048.png)

异或运算：相同为0，不同为1，或者理解为不进位相加

![1666081407183](algorithm.assets/1666081407183.png)

不开辟额外空间交换两个数，**但是要保证a和b指向的内存不同**，因此在上面那个方法中，**i一定不能等于j**

![1666081570256](algorithm.assets/1666081570256.png)

**面试题：在一堆数中，有一个数出现了奇数次，其他数都出现了偶数次，找出这个奇数次的数**

![1666081981177](algorithm.assets/1666081981177.png)

思路：使用异或运算，每个数都跟eor异或，最终得到就是那个奇数次的数

![1666082020110](algorithm.assets/1666082020110.png)

**面试题：在一堆数中，有两个数出现了奇数次，其他数都出现了偶数次，找出这两个奇数次的数**

 一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。 

![1666083510316](algorithm.assets/1666083510316.png)

在一堆数中进行异或，最终结果就是a^b，他们肯定不等于0，表示a和b用二进制表示至少有一位是1，即有一个位置a和b不相同，假设为第8位，根据这个第8位将原数组进行分类，分为第8位是1的数和第8位是0的数，而a和b只可能分别在两边，此时用一个变量去异或第8位是1的数，此时这个变量一定是a或者b，再让他和eor进行异或，即可得到另一个数

提取一个数最右侧的1：

![1666084222500](algorithm.assets/1666084222500.png)

![1666084231117](algorithm.assets/1666084231117.png)

代码有问题，最终应该是 == 0 ，因为只能分为  ==0或者 ！=0两个部分，因为有可能会遇到5&4=4进不去if判断

![1666084329319](algorithm.assets/1666084329319.png)

如果是 在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 

 [剑指 Offer 56 - II. 数组中数字出现的次数 II - 力扣（Leetcode）](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solutions/1161386/ji-yu-krahetsda-lao-gei-chu-de-you-xian-67dkc/) 

**插入排序**

![1666084393362](algorithm.assets/1666084393362.png)

![1666085142768](algorithm.assets/1666085142768.png)

一直往前面比较，直到比前面大就结束

**二分法**

![1666085341263](algorithm.assets/1666085341263.png)

局部最小值就是 i 位置的数要小于其左右两边的数，求局部最小值也可以用二分

**对数器**

![1666096804589](algorithm.assets/1666096804589.png)

随机数组方法

![1666097147483](algorithm.assets/1666097147483.png)

![1666097181979](algorithm.assets/1666097181979.png)

## 认识O(NlogN)的排序

**递归**

![1666098253661](algorithm.assets/1666098253661.png)

 求中点位置防止溢出：右移一位

![1666098374004](algorithm.assets/1666098374004.png)

![1666098429150](algorithm.assets/1666098429150.png)

master 公式的介绍：只要是子问题等规模就可以用master公式求解

母问题N个数据，子问题每次都是 N/b 的规模，a指的是子问题调用次数，后面的是除了子问题外剩下过程的时间复杂度

![1666099083933](algorithm.assets/1666099083933.png)

所以求出来是这样

![1666100229210](algorithm.assets/1666100229210.png)

求解时间复杂度：

![1666160016678](algorithm.assets/1666160016678.png)

**归并排序**

![1666160159428](algorithm.assets/1666160159428.png)

![1666160387992](algorithm.assets/1666160387992.png)

![1666160452617](algorithm.assets/1666160452617.png)

思路：将数组分为两边，左右都排序完毕后merge合并，双指针比较，谁小谁进入help数组，直到一方越界，然后将剩下的全部复制进help数组

**拓展**

![1666161607608](algorithm.assets/1666161607608.png)

思路：

1. “这个数左边比它小的数字的和” 等同于 “这个数右边有几个数比它大，这个数就会被计算进几次小和，就把这个数乘几次”
2. 利用归并排序中的merge步骤计算小和，可以将复杂度从O ( N 2 ) O(N^2)O(N )改进为O ( N l o g N ) O(NlogN)O(NlogN)。同时，利用merge时并入的两个序列分别有序的特性可以省去不必要的比较，如[134]并入[25]时，2>1直接推出2后面的数都>1，因此直接+=1*(endIndex-indexOf(2)+1)即可。

为什么利用mergeSort既不会重复也不会漏算？
比如，对于数组 [1,3,4,2,5]，1会依次和3比较，组成[1,3]; 再与4比较，组成 [1,3,4]; 再与 [2,5]比较，组成[1,2,3,4,5]。[1,3,4]内部不会重复比较，同时1也会与每一个其右边的数字分别进行比较，不会遗漏。

![1666163210485](algorithm.assets/1666163210485.png)

求小和的合并过程中，如果是两边相等，一定要保证是右组先合并进去，否则无法计算小和

![1666163903763](algorithm.assets/1666163903763.png)

process函数中return的是左侧排序求小和的数量+右侧排序求小和的数量+merge合并时产生小和的数量

拷贝的时候只有严格左组比右组小才拷贝左组，否则拷贝右组

![1666164429590](algorithm.assets/1666164429590.png)

逆序对也是一样的思路,只需要将归并倒序排序，p1 > p2 时，表明p1大于整个右边部分

```java
public int reversePairs(int[] nums) {
    return process(nums, 0, nums.length-1);
}

public int process(int[] nums, int L, int R) {
    if (L >= R) { // for nums=[]
        return 0;
    }
    int mid = L + ((R-L) >> 1);
    return process(nums, L, mid) +
           process(nums, mid+1, R) +
           merge(nums, L, mid, R);
}

public int merge(int[] nums, int L, int M, int R) {
    int[] help = new int[R-L+1];
    int pair = 0;
    int p1 = L;
    int p2 = M+1;
    int i = 0;
    while (p1<= M && p2<= R) {
        if (nums[p1] > nums[p2]) {
            pair += R-p2+1;
            help[i++] = nums[p1++];
        } else {
            help[i++] = nums[p2++];
        }
    }
    while (p1<= M) {
        help[i++] = nums[p1++];
    }
    while (p2<= R) {
        help[i++] = nums[p2++];
    }
    for (int j=0; j<help.length; j++) {
        nums[L+j] = help[j];
    }
    return pair;
}

```

**快速排序**

![1666165024588](algorithm.assets/1666165024588.png)

![1676712343003](algorithm.assets/1676712343003.png)

![1666182181181](algorithm.assets/1666182181181.png)

问题一思路：开始的时候设定一个变量表示小于等于的区域的边界，然后边界刚开始在最左边，然后从数组第一个数开始比较，若小于等于num，则当前这个数和边界区的下一个数交换，然后小于等于边界区右扩，i++到下一个数，如果是大于，则直接指针下一个

![1666182514347](algorithm.assets/1666182514347.png)

![1676712593347](algorithm.assets/1676712593347.png)

![1676712608599](algorithm.assets/1676712608599.png)

![1676712629585](algorithm.assets/1676712629585.png)

问题二思路：两个边界，三种判断情况，第三种是 i 原地不动，当大于区域和 i 相等时停止

**快排1.0版本**

![1666182885872](algorithm.assets/1666182885872.png)

刚开始拿数组最后一个数做number，让左边排序成<=number和>number两个部分，然后让number和>区域的第一个交换，然后递归，在<=区域的最后位置选为number，>区域也是

在数组中最后一个数，放到小于等于区域的最后一个位置，然后小于等于区域去递归，大于区域也递归，每次排好一个数，就能有序

**快排2.0版本**

利用荷兰国旗问题

思路：一开始在整个范围上用最后一个数做划分，让前面的范围做到都是小于5，中间都是等于5，右边是大于5，让5和大于5区域的第一个数交换，然后在左右递归，一次排好一批数，比1.0更快

![1676713019753](algorithm.assets/1676713019753.png)

![1666183304726](algorithm.assets/1666183304726.png)

这两种，时间复杂度都是O(N^2)

![1666335531263](algorithm.assets/1666335531263.png)

**快排3.0**

随机选一个数，和最后一个数交换，作为划分

此时时间复杂度为O(NlogN)

![1666184335652](algorithm.assets/1666184335652.png)

partition返回的数组长度一定为2

![1666184447403](algorithm.assets/1666184447403.png)

返回的是12和13，表示返回的是等于区域的左边界和右边界

p[0]是等于区域的左边界，所以-1去左边递归

partition就是荷兰国旗问题

![1666184515520](algorithm.assets/1666184515520.png)

## 详解桶排序以及排序内容总结

**堆**

![1666335848491](algorithm.assets/1666335848491.png)

完全二叉树：节点从左到右的填充的就是完全二叉树，只有左节点也叫完全二叉树，但是略过左节点直接到右节点就不是完全二叉树

数组转完全二叉树的关系：

除法是向下取整

![1666336818574](algorithm.assets/1666336818574.png)

转化大根堆，就是每个数跟自己父亲比较，若大则交换

![1666337173736](algorithm.assets/1666337173736.png)

如果需要删掉大根堆的头节点，那么我们将堆最后一个数字移到头节点，然后堆的大小-1，然后循环用头节点比较他的两个字节点中的最大值，若小于则交换，重复此操作，保证一直是堆结构 

![1666337568531](algorithm.assets/1666337568531.png)

**堆排序**

![1666338178975](algorithm.assets/1666338178975.png)

思路：先用heapInsert将数组调整为堆结构，然后重复将最后一位跟头节点交换后，将0位置做heapify操作，最后即可排序完毕，成为从小到大排序

算法整体复杂度为：O(N*logN)

细节再优化：

将数组调整为堆结构的代码可以再优化成这样，从最后开始往下做heapify调整(即每个子树先调整为大根堆)

![1666338986207](algorithm.assets/1666338986207.png)

这一步的复杂度是O(N)

![1666338921044](algorithm.assets/1666338921044.png)

 拓展题目

![1666339118419](algorithm.assets/1666339118419.png)

有些题目，只需要一个小根堆结构，不需要修改其中的值之类的操作，就可以用系统提供的堆结构函数，如果需要更复杂的调整，则手写的效率更高

![1666345354135](algorithm.assets/1666345354135.png)

思路：先把前几个数放到小根堆中，每次弹出一个数放到数组中，然后新加一个数放到堆中，每次弹出的就是最小值

**比较器**

![1666363847555](algorithm.assets/1666363847555.png)

![1666592753793](algorithm.assets/1666592753793.png)

可以改写成容易理解的样子

![1666592820385](algorithm.assets/1666592820385.png)

就是如果第一个参数更小就返回负数，第一个更大则返回正数，这就是升序

![1666593065643](algorithm.assets/1666593065643.png)

如果是Id降序则用第二个参数-第一个参数

![1666593122750](algorithm.assets/1666593122750.png)

比较器还能用在堆之类的结构中，传个比较器

大根堆就是用第二个参数减第一个

![1666593872284](algorithm.assets/1666593872284.png)

复杂数据，自己定义的类，用这种方式会很方便

**桶排序**

桶可以是任意数据结构，这题我们用队列

对这几个数进行补全，补成3位数，然后按照个位数放到桶里

![1666594735940](algorithm.assets/1666594735940.png)

然后从头开始倒出来

![1666594752384](algorithm.assets/1666594752384.png)

先进桶的先出来，队列先进先出

然后根据十位数再放进桶里面

![1666594804548](algorithm.assets/1666594804548.png)

再倒出来

![1666594819163](algorithm.assets/1666594819163.png)

再按照百位数进桶

![1666594832513](algorithm.assets/1666594832513.png)

再倒出来就排好序了

![1666594846138](algorithm.assets/1666594846138.png)

![1666595099362](algorithm.assets/1666595099362.png)

![1666595115177](algorithm.assets/1666595115177.png)

digit参数表示这些数中最大的数字有几个十进制位

![1666595166072](algorithm.assets/1666595166072.png)

![1666596160217](algorithm.assets/1666596160217.png)

这里不是用桶搞得，是优化了很多，但是思想是这样得，用得是词频表，个位数是几就在下表处++

![1666595329327](algorithm.assets/1666595329327.png)

然后让他变成前缀和数组，所以现在下标2的4变成了个位数小于等于2的数有4个

![1666595437309](algorithm.assets/1666595437309.png)

此时我们从右往左看，062这个数，是最右侧，他一定是最后一个进桶的，根据先进先出，而个位数小于等于2的数只有4个，所以062一定是在help数组的下标3位置(即第四个数)，然后词频-1

![1666595655355](algorithm.assets/1666595655355.png)

以此类推

![1666595708453](algorithm.assets/1666595708453.png)

**排序算法的稳定性及其汇总**

![1666596346803](algorithm.assets/1666596346803.png)

稳定性指的是，相同的元素能否保证在排序完后保证其原来次序不变

![1666597159455](algorithm.assets/1666597159455.png)

一般都会选择快速排序，能用快排就用快排

![1666597318865](algorithm.assets/1666597318865.png)

![1666597524621](algorithm.assets/1666597524621.png)

例如快排加上一段

![1666597559468](algorithm.assets/1666597559468.png)

就是小样本量时，我们直接用插入排序，更快，这种叫综合排序

系统提供的Array.sort，如果是基础数据类型，就会用快排，如果是非基础数据类型就用归并，因为要稳定性

## 链表

![1666598588661](algorithm.assets/1666598588661.png)

hashSet没有值，只有key，hashMap有value，第一次是添加，第二次是更新

哈希表的所有增删改查时间复杂度都是常数级别

![1666598725271](algorithm.assets/1666598725271.png)

不是基础类型，内存占用就是8字节

![1666598931104](algorithm.assets/1666598931104.png)

所以这里的nodeA和nodeB不一样

![1666599917233](algorithm.assets/1666599917233.png)

有序表，根据key组织

有序表的增删改查都是O(logN)

![1666600055763](algorithm.assets/1666600055763.png)

不是基础类型，没给比较器会报错

![1666600135968](algorithm.assets/1666600135968.png)

**单链表**

![1666600204581](algorithm.assets/1666600204581.png)

![1666600272499](algorithm.assets/1666600272499.png)

如果有换头操作，则需要返回头节点

![1666600727143](algorithm.assets/1666600727143.png)

```java
package com.zzw.test;

/**
 * @program: HashMapTest
 * @description: 双向链表反转
 * @author: zhaozhenwei
 * @create: 2021-05-30 10:55
 **/
public class DoubleListInversion {

    public static void main(String[] args) {
        DoubleNode listInversion = createListInversion();
        printListInversion(listInversion);
        printListInversion(inversion(listInversion));

    }

    /**
     * 链表反转
     *  currentNode 当前处理的节点
     *  previous    处理的上一个节点     初始情况下为null
     *  next        要处理的下一个节点    初始情况下为第一个节点的下一个节点
     *   通过死循环进行处理，跳出判断放在循环内
     *   将当前节点的上一个节点currentNode.previous执行要处理的下一个节点next
     *   将当前节点的下一个节点currentNode.next指向上次处理的节点previous
     *   此时当前节点处理完成，进行下一个节点处理的初始化
     *      previous指向当前处理的节点currentNode
     *      判断当前节点currentNode的下一个节点next是否为null，如果为null说明当前节点currentNode是最后一个节点，跳出循环
     *          如果不为null，将下一个节点指向next.next
     * @param node
     * @return
     */
    public static DoubleNode inversion(DoubleNode node) {
        if (null == node) {
            throw new RuntimeException("反转链表起始节点不能为null");
        }
        // 当前节点
        DoubleNode currentNode = node;
        // 上个节点
        DoubleNode previous = null;
        // 下个节点
        DoubleNode next = currentNode.next;
        while (true) {
            currentNode.previous = next;
            currentNode.next = previous;
            previous = currentNode;
            if (null == next) {
                break;
            }
            currentNode = next;
            next = next.next;
        }
        return previous;
    }

    /**
     * 打印链表
     * @param node
     */
    static void printListInversion(DoubleNode node) {
        DoubleNode currentNode = node;
        while (null != currentNode) {
            System.out.println(currentNode);
            currentNode = currentNode.next;
        }
        System.out.println();
    }

    /**
     * 创建链表
     * @return
     */
    static DoubleNode createListInversion() {
        DoubleNode n1 = new DoubleNode(1);
        DoubleNode n2 = new DoubleNode(2);
        DoubleNode n3 = new DoubleNode(3);
        DoubleNode n4 = new DoubleNode(4);
        DoubleNode n5 = new DoubleNode(5);

        n1.previous = null;
        n1.next = n2;

        n2.previous = n1;
        n2.next = n3;

        n3.previous = n2;
        n3.next = n4;

        n4.previous = n3;
        n4.next = n5;

        n5.previous = n4;
        n5.next = null;

        return n1;
    }


}



class DoubleNode {
    int value;
    DoubleNode previous;
    DoubleNode next;
    public DoubleNode(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "DoubleNode{"
                + "previous: " + (null == previous ? "null" : previous.value) +
                "\tvalue=" + value
                + "\tnext:" + (null == next ? "null" : next.value) + "}";
    }
}

```



![1666600353231](algorithm.assets/1666600353231.png)

谁小谁移动，相同就打印然后一起移动

![1666601112618](algorithm.assets/1666601112618.png)

![1666601171484](algorithm.assets/1666601171484.png)

用个栈然后遍历比较就行

可以只放右侧进栈就行，可以省一半空间，此时需要使用快慢指针技巧，快指针一次走两步，慢指针一次一步，快指针到终点的时候，慢指针就在中间了

![1666601536490](algorithm.assets/1666601536490.png)

可能边界条件不同，还分奇偶

如果只用几个变量，不用额外空间

![1666601713809](algorithm.assets/1666601713809.png)

使用快慢指针，慢指针到中点，然后继续遍历时，让中点指向空，其他的反转，然后用变量记住头节点和尾节点，然后他们同时往中间走，每一步都一样即可，有一个走到空就停，但是返回结果前要把链表恢复

方法一：

![1666601905145](algorithm.assets/1666601905145.png)

![1666601952442](algorithm.assets/1666601952442.png)

方法二：

![1666601993204](algorithm.assets/1666601993204.png)![1666602120750](algorithm.assets/1666602120750.png)



![1666602161560](algorithm.assets/1666602161560.png)

思路：笔试就直接申请一个Node类型数组，然后在数组中进行划分，然后再遍历链接即可

进阶：使用6个变量，分别是小于部分的头指针和尾指针，等于部分的头指针和尾指针，大于部分的头指针和尾指针，一开始都指向空，在遇到第一个时则将头尾都指向它，然后第二个时，将第一个指向第二个，然后尾指针指向第二个，最终让小于部分的最后那个节点指向等于部分的头节点，等于部分的尾节点指向大于部分的头节点即可

![1666602499890](algorithm.assets/1666602499890.png)

注意一定要考虑边界，有可能没有小于部分

方法一：

![1666602746364](algorithm.assets/1666602746364.png)

![1666602789312](algorithm.assets/1666602789312.png)

![1666602802698](algorithm.assets/1666602802698.png)

方法二：

![1666602723500](algorithm.assets/1666602723500.png)

![1666602868725](algorithm.assets/1666602868725.png)

![1666602881912](algorithm.assets/1666602881912.png)



![1666602916913](algorithm.assets/1666602916913.png)

使用一个map，key为老节点，value为新复制的节点，遍历每一个老节点将其放到map中，然后开始设置指针连接方向

![1666614270415](algorithm.assets/1666614270415.png)

方法二：不用map，直接用新的节点接到老节点后面，不管rand指针

![1666614460384](algorithm.assets/1666614460384.png)

然后，遍历的时候一对一对拿，拿1和1`，只考虑其rand指针，通过1的rand指针得到3，此时3后面就是1撇得rand指针3撇，最后分离next指针

![1666614717925](algorithm.assets/1666614717925.png)

![1666614760435](algorithm.assets/1666614760435.png)



![1666701524413](algorithm.assets/1666701524413.png)

判断有环和第一个入环节点，就是使用一个hashSet，每次遍历就将节点放入其中，每次判断是否已经在Set中存在，若存在则是第一个入环节点

![1666765361344](algorithm.assets/1666765361344.png)

还可以使用快慢指针：快指针走到空说明无环，快指针一次两步，慢指针一次一步，总有一步是两个相遇，而且在环上转的圈数不会大于两圈，然后当相遇时，快指针回到头节点，慢指针不动，然后两个都一次走一步，他们一定会在第一个入环节点相遇

![1666765887441](algorithm.assets/1666765887441.png)

这里快慢指针都先走了一次，以免进入不了循环

根据这个可以开始判断相交的第一个节点

如果两个单链表有相交，而且无环，那么一定最后是公共部分

![1666766288290](algorithm.assets/1666766288290.png)

所以我们可以遍历两个链表，记录头节点和尾节点以及长度，比较两个尾节点的内存地址，如果不同则表明一定没有相交

![1666766489928](algorithm.assets/1666766489928.png)

如果链表1比链表2长20步，那么链表1先走20步，然后链表2从头开始，他们一定会在第一个相交节点相遇

![1666766647448](algorithm.assets/1666766647448.png)

![1666766697258](algorithm.assets/1666766697258.png)

![1666766876796](algorithm.assets/1666766876796.png)

第二种情况，如果一个有环，一个无环，即一个遍历到最后为null，一个不为null

![1666767540278](algorithm.assets/1666767540278.png)

这种情况都是不可能相交的

第三种情况:两个链表都有环

![1666767760104](algorithm.assets/1666767760104.png)

设head1的入环节点是loop1，head2的是loop2，比较loop1和loop2的内存地址，相等时则表示是第二种情况，此时求第一个相交节点，此时我们将入环节点当成尾节点，然后和上面一样，直接比较长度，长的先走，然后一起走就能到第一个相交节点，即无环链表相交问题

判断情况一和情况三：让loop1继续走，如果能遇到loop2则是情况三，如果遇不到就是情况一

则情况一就是null，而情况三则是返回loop1和loop2都对，因为都是第一个相交节点

![1666768147365](algorithm.assets/1666768147365.png)

![1666768173404](algorithm.assets/1666768173404.png)

主函数调用：

![1666768250453](algorithm.assets/1666768250453.png)

先使用getLoopNode方法(快慢指针相遇)得到入环节点



## 二叉树

![1666768457369](algorithm.assets/1666768457369.png)

![1666768599448](algorithm.assets/1666768599448.png)

先序遍历：先遍历头节点，再左节点，再右节点

中序遍历：先左节点，然后头节点，然后右节点

后序遍历：先左节点，然后右节点，然后头节点

![1666854677983](algorithm.assets/1666854677983.png)

递归改为非递归：使用栈

先序遍历:先头节点压栈，然后弹出，打印，然后先右后左，循环处理

![1666854978279](algorithm.assets/1666854978279.png)

![1666855136919](algorithm.assets/1666855136919.png)

后序遍历的非递归：可以使用两个栈，先在第一个栈按照头左右加入，然后弹出来的都放另一个收集栈中

![1666867760365](algorithm.assets/1666867760365.png)

因为是头左右，所以放入收集栈中是头右左，打印的顺序是逆序，即左右头，所以是后序遍历

中序遍历非递归：准备一个栈，先把所有左节点压栈，然后弹出每一个时将右节点也压栈

![1666868159431](algorithm.assets/1666868159431.png)

![1666876162541](algorithm.assets/1666876162541.png)

 ![1666876651267](algorithm.assets/1666876651267.png)

宽度遍历使用队列：先放头节点，然后弹出，打印，然后先放左再放右

![1666876939335](algorithm.assets/1666876939335.png)

求一棵树的最大宽度：

![1666877284504](algorithm.assets/1666877284504.png)

![1666877499544](algorithm.assets/1666877499544.png)

不用哈希表：用两个变量存储当前层的最后一个节点和下一层的最后一个节点，这样的判断机制

**二叉树的相关概念及其实现判断**

![1666942754446](algorithm.assets/1666942754446.png)

搜索二叉树：对于 任意一棵子树，左节点都比他小，右节点都比他大

判断搜索二叉树：使用中序遍历，肯定是依次升序，否则就不是搜索二叉树

![1666943238114](algorithm.assets/1666943238114.png)

prevalue就是上一个的值，判断如果左树不是BST则直接返回false，如果head.value小于等于也是不行，然后把当前值设置位preValue，然后用当前的右树去递归

非递归方式：

![1666943727355](algorithm.assets/1666943727355.png)

**判断完全二叉树**

完全二叉树要么是满的，要么是只有最后一层不满，而且也必须是要变满的样子

思路：

- 利用宽度遍历，任一个节点有右无左则直接false
- 在第一个条件不违反的情况下，如果遇到了第一个左右孩子不全的时候，后续所有的节点都必须是叶子节点

![1666944062587](algorithm.assets/1666944062587.png)

![1666944123199](algorithm.assets/1666944123199.png)

![1666944159474](algorithm.assets/1666944159474.png)

 蓝色部分的判断是两个判断条件，第一个是指出现了左右孩子不全的情况并且它不是叶子节点，则返回false

**判断满二叉树**

 麻烦的办法：求出最大深度和节点数，然后用公式  N = 2^l - 1

![1666944530253](algorithm.assets/1666944530253.png)

**判断平衡二叉树**

平衡二叉树：左树和右树的高度差不超过 1 

![1666945900463](algorithm.assets/1666945900463.png)

![1666945962537](algorithm.assets/1666945962537.png)

二叉树递归套路：左树是，右树是，xxx

例如二叉搜索树：左树是搜索树，右树是搜索树，左边max < x，右边min > x，所以递归的返回条件可以定为：是否是搜索树，左树最大值，右树最小值

![1666946430926](algorithm.assets/1666946430926.png)

![1666946625138](algorithm.assets/1666946625138.png)

这其实就是树型DP，通过左右两个子树信息来得到当前信息

**满二叉树**

只告诉高度和个数

![1667024578483](algorithm.assets/1667024578483.png)

![1667024846876](algorithm.assets/1667024846876.png)

主函数得到整棵树的高度和节点数，用公式，2^l -1

![1667024878173](algorithm.assets/1667024878173.png)

这种套路不是所有题目都能解出，比如要求中位数，那不能通过左树的中位数和右树的中位数就得到全部的中位数

----

最近公共祖先

![1667026354577](algorithm.assets/1667026354577.png)

就是找两个节点网上最初汇聚的节点

![1667026534674](algorithm.assets/1667026534674.png)

通过递归把所有节点的父节点都保存到Map集合里面

![1667027001273](algorithm.assets/1667027001273.png)

然后再将第一个节点的父节点都录到一个Set集合里面，就是当前节点不跟它的父节点相同则保存进去，直到头节点循环停止，然后你再把头节点放进去，然后用循环遍历第二个节点o2，当遇到第一个父亲节点在Set集合里面就表示找到了最低公共祖先

![1667027322308](algorithm.assets/1667027322308.png)

更加抽象的代码：

可以分为几个情况：

- o1是o2的LCA，或者o2是o1的LCA
- o1和o2彼此不是最低公共祖先

这个代码意思是：如果某个子树上没有o1或者o2，那么这个子树一定返回空，遇到o1或o2直接往上返回

而如果两个节点不互为LCA，那么有o1的子树会返回o1，有o2的子树会返回o2，此时会中那个if判断条件，返回他们的头节点

![1667028114155](algorithm.assets/1667028114155.png)

![1667028776049](algorithm.assets/1667028776049.png)

----

在二叉树中找到一个节点得后继节点

![1667029018963](algorithm.assets/1667029018963.png)

前驱节点也是在中序遍历中

虽然可以直接遍历后得到中序遍历的list，但是这样复杂度为O(N)，实际上我们通过父指针可以直接得到后继节点，所以想以此优化

- 当x有右树时，x的后继节点是右树的最左节点 
- 当x无右树时，x的后继节点是一直往上判断是不是父亲节点的左节点，知道找到那个是父亲节点左节点的父亲节点
- 整棵树最右节点没有后继节点

![1667030478206](algorithm.assets/1667030478206.png)

![1667030542471](algorithm.assets/1667030542471.png)

![1667030569124](algorithm.assets/1667030569124.png)

当parent是空的时候，说明了这个节点是整棵树的最右节点，没有后继节点

----

![1667030699463](algorithm.assets/1667030699463.png)

先序后序中序来遍历序列化都行，本质上一样

按先序序列化那就按先序给反序列化

![1667031379170](algorithm.assets/1667031379170.png)

![1667031440535](algorithm.assets/1667031440535.png)

----

给定一个参数n，请打印一张纸一直对折n次后打开后的折痕方向

规律：在第一次折痕上方会出现一个凹折痕，下方出现一个凸折痕，改成二叉树结构就会发现，左子树头节点都是凹，右子树头节点都是凸，所以打印就是直接中序遍历就行

![1667033203881](algorithm.assets/1667033203881.png)

![1667033284518](algorithm.assets/1667033284518.png)

----

## 图

![1667718525442](algorithm.assets/1667718525442.png)

邻接表法：大体上是以点为单位，每个点的直接邻接点写在后面

![1667718709407](algorithm.assets/1667718709407.png)

带权值的

![1667718755615](algorithm.assets/1667718755615.png)

邻接矩阵：

![1667718816145](algorithm.assets/1667718816145.png)

还可以用数组或者其他方式表达图，最好的方式是用自己最会的方式写好模板，到时只需要做转化就行，比用题目给的数据结构来实现一遍算法更加快和稳定

图

![1667719181540](algorithm.assets/1667719181540.png)

一个是点集，一个是边集

点：

也可以将value改为String类型

![1667719256854](algorithm.assets/1667719256854.png)

in表示入度，指有多少条边到这个点来，out表示出度

next表示从这个点发散出去的边所指向的点

edges表示属于这个点的边（从这个点发散出去的边）

----

边：

![1667719569175](algorithm.assets/1667719569175.png)

假设用户给的是这种类型的数组：

![1667721561286](algorithm.assets/1667721561286.png)

需要转化为我们熟悉的

![1667721583159](algorithm.assets/1667721583159.png)

nodes是点集，哈希表结构，key为点的指，value是指这个点

查找有无from和to点，然后获得，然后建立一个新的边，然后修改值

如果具体题目有些数据项不需要，就可以不填

----

![1667722213541](algorithm.assets/1667722213541.png)

![1667722404250](algorithm.assets/1667722404250.png)

这个Set是为了保证不要重复进队列

其实哈希表可以替换为数组，因为有些题目就是数字，而且数据量不大，所以可以数组寻址更快

![1667722751788](algorithm.assets/1667722751788.png)

----

![1667723106231](algorithm.assets/1667723106231.png)

![1667723319098](algorithm.assets/1667723319098.png)

首先找到入度为0的节点，然后将其影响的边擦掉，再找入度为0的节点

![1667723357274](algorithm.assets/1667723357274.png)

所以拓扑排序的下一个是B，以此类推

![1667723410619](algorithm.assets/1667723410619.png)

----

![1667724205963](algorithm.assets/1667724205963.png)

这个算法就是为了生成最小生成树

最小生成树：保证所有点是连通的，同时权值要最小

![1667724277831](algorithm.assets/1667724277831.png)

算法：从最小的边开始考虑，如果加上的时候没有环就加上，形成了环就不行

所以就是要考虑，如何在加上边后判断是不是形成了环，即并查集

首先每个点都是一个单独的集合，加上一个边后判断是不是在同一个集合，如果不是则将其加到一个集合内

![1667724577118](algorithm.assets/1667724577118.png)

这里不展开讲并查集，可以自行查资料，这里用一种简单结构来做

首先建立结构，每个点都有一个自己的集合

![1667725939885](algorithm.assets/1667725939885.png)

然后实现一个接口，判断两个节点是否在同一个集合里面，就判断这两个集合是否内存地址一样就行

![1667726005862](algorithm.assets/1667726005862.png)

然后是如果不在同一个集合，就要合并到同一个集合中

就是把所有toSet中的节点加入到fromSet中，然后把toSet的指向的List改为fromSet

![1667726278416](algorithm.assets/1667726278416.png)

实现这些功能后，使用k算法

![1667727007975](algorithm.assets/1667727007975.png)这里的unionFind就是并查集，可以用刚才写的方法替代

![1667727104380](algorithm.assets/1667727104380.png)

----

prim算法生成最小生成树

![1667727212963](algorithm.assets/1667727212963.png)

从哪条边出发都行，刚开始认为所有边都没有解锁

从A出发，就是6，1，5这三条边解锁，然后选择最小的1，C就加入集合中

![1667727648978](algorithm.assets/1667727648978.png)

然后就又多了5，5，6，4这4条边解锁了，加上刚才还有2条边，从这里面选一个最小的

然后如果遇到相同权值的边，那就要考虑是否已经加入了集合

![1667727985506](algorithm.assets/1667727985506.png)

用Set集合来判断是否已经考察过了这个点

![1667728261103](algorithm.assets/1667728261103.png)

这个代码会把重复的边放到里面去，但是不影响结果，因为就算重复的边放进去了，对应的点也已经加入到Set中了，会被if给过滤掉

而最外面的for循环是处理森林问题

![1667728692792](algorithm.assets/1667728692792.png)

寻找下一个整体连通的区域，找到最小生成树加入到result中，如果一开始都是连通的，那就不用这个大的for循环

----

![1667728754372](algorithm.assets/1667728754372.png)

用于寻找单元最短路径，适用范围实际上可以有负数边，但是不能有累加和为负数的环

规定一个出发点，求从这个点到后续每一个点的最短距离

![1667728850130](algorithm.assets/1667728850130.png)

初始时，自己到自己是0，其他都是无穷

![1667728918039](algorithm.assets/1667728918039.png)

然后判断A可以到的点，是否将原来的记录变得更短，变了就改写

![1667728987667](algorithm.assets/1667728987667.png)

使用完A后就锁定，再也不用A了，然后剩下中最小的到B，发现B到外面也有3条路，指向A的路是3，但是A到A已经是0，没有更小，所以不改，然后发现B到C有个2，更小，改写A-C为3+2=5

![1667729139154](algorithm.assets/1667729139154.png)

![1667729326100](algorithm.assets/1667729326100.png)

getMinDistanceAndUnselectedNode()是在distanceMap中找到一个最小的记录，但是不能是已经处理过的

![1667729609734](algorithm.assets/1667729609734.png)

就是，如果一个最小距离的节点，他的每一条边，如果原本没路的地方有路了就新加进去，如果让一个之前有路的距离变得更小了就更新

可以用堆来改写，但是不能用系统的堆，因为你会修改值，而系统提供的就不太合适，得自己改写

就是维护一个可以修改的小根堆，每次选取节点后能更改堆中节点的值后还能调整为小根堆

![1669774949089](algorithm.assets/1669774949089.png)

nodes数组是堆的底层结构，然后heapIndexMap用来存储每个节点在堆中的下标位置，distanceMap用于存储node到head目前的最短距离，size表示目前这个堆有多少个节点

![1669776852507](algorithm.assets/1669776852507.png)

isEntered方法判断node是否已存在堆中，本来堆中是要弹出的，但是我们在heapIndexMap中是一直有记录的，弹出了就标记为-1

inHeap就是判断是否在堆中

swap交换方法是在堆中要交换位置

![1669777123896](algorithm.assets/1669777123896.png)

这几个方法之前讲过

![1669777257634](algorithm.assets/1669777257634.png)

addOrUpdateOrIgnore方法是指如果一个新的节点进来就增加记录，如果一个新的记录进来比之前的记录更小就更新，如果比之前更大就忽略

第一个if判断如果有新的值进来了，节点已在堆中，则更新distanceMap，然后用insertHeapify进行堆的调整

第二个if是如果没有进来过堆，就新建

![1669775102835](algorithm.assets/1669775102835.png)

![1669777692385](algorithm.assets/1669777692385.png)

![1669776639048](algorithm.assets/1669776639048.png)

----

## 前缀树

![1667806960449](algorithm.assets/1667806960449.png)

![1667807276580](algorithm.assets/1667807276580.png)

根据字符串建立前缀树，字符一般在路上，如果前面出现过就复用，没有就新建

![1667807577910](algorithm.assets/1667807577910.png)

![1667807564199](algorithm.assets/1667807564199.png)

走过了哪里就p+1，结尾的节点就是e+1

![1667807637008](algorithm.assets/1667807637008.png)

![1667807774199](algorithm.assets/1667807774199.png)

建好一棵树后，我们可以查询bc是否出现过，就是直接去找，看b这条路有没有，c这条路有没有，然后看c这个节点的e值是否为0，不为0表示bc出现过

现在求：之前加的字符串，有多少个字符串是以 ab 作为前缀的

其实就是求p值，p值代表这个节点被通过了几次

![1667808591354](algorithm.assets/1667808591354.png)

----

## 暴力递归

![1671777352708](algorithm.assets/1671777352708.png)

![1671777608793](algorithm.assets/1671777608793.png)

哈诺塔只能小的在大的上面

![1671777724973](algorithm.assets/1671777724973.png)

这个问题可以理解为，1~i个圆盘从from到to位置，还有一个other辅助，可以分为以下三步

![1671777885130](algorithm.assets/1671777885130.png)

然后不断拆分

![1671777941378](algorithm.assets/1671777941378.png)

----

![1671778147025](algorithm.assets/1671778147025.png)

![1671778270903](algorithm.assets/1671778270903.png)

从左到右每个位置穷举要或者不要

![1671778502745](algorithm.assets/1671778502745.png)

省空间做法，直接改str

![1671778644502](algorithm.assets/1671778644502.png)

----

![1671778688708](algorithm.assets/1671778688708.png)

排列就是第一个位置是n种可能，第二个位置是n-1种可能，以此类推

![1671778983092](algorithm.assets/1671778983092.png)

![1671779043942](algorithm.assets/1671779043942.png)

每次把第i个字符与后续的字符进行交换后进行process过程，然后再交换回来

那么如何保证不重复进行？

用visit表进行存储每个字符串位置是否尝试过，试过就不尝试了

![1671779186927](algorithm.assets/1671779186927.png)

也可以直接全部排列出来再把重复的洗掉，但是这样做在常数项上就更慢点

而这里采用的是分支限界，提前处理不可以尝试的路

----

![1671779383798](algorithm.assets/1671779383798.png)

实际上就是要分先手和后手两个函数来确定，先手的时候，先拿一个以后，轮到对方先手，再拿后手函数里面最大的，后手的时候，如果到了base case，则拿不到牌，否则就是对方先手拿完后，轮到我方先手，但是只能得到最小的，因为对方会把最差情况留给我们。不需要考虑太长远，只需要在某一个范围内保持这样的决策

![1671780572375](algorithm.assets/1671780572375.png)

----

![1671780660781](algorithm.assets/1671780660781.png)

先定义一个函数，将栈底元素弹出并返回

![1671780795885](algorithm.assets/1671780795885.png)

从reverse开始

![1671780938680](algorithm.assets/1671780938680.png)

----

![1671781024950](algorithm.assets/1671781024950.png)

假定 i 之前的位置已经决定好了，求 i 之后的转化结果

![1671781348124](algorithm.assets/1671781348124.png)

当来到字符最后一个时，表示前面的转化都决定好了，这就是一种转化结果，所以返回1

当遇到0的时候，表示现在坠入了一种无效状态，所以整体0种有效状态

当现在压中了1，那么我们可以有两种选择，一种是 i 作为自己单独的，后续有多少种，另一种是 i 和 i+1 作为一个整体，看后续有多少种，这两种情况应该相加

当压中2时，要考虑不能超过26，剩下最后就是3~9时，只有一种决定

----

![1671781699218](algorithm.assets/1671781699218.png)

这种情况就可以直接全部展开，0~i 要或者不要全部计算，也是只管 i 往后的货物自由选择

选择就是判断最大，如果 i 号货物不要，则从 i+1号开始进行判断，如果 i+1要，则加上当前重量

![1671782004830](algorithm.assets/1671782004830.png)

也可用这种方法

![1671782174568](algorithm.assets/1671782174568.png)

----

![1671782247632](algorithm.assets/1671782247632.png)

![1671782438607](algorithm.assets/1671782438607.png)

每次从新的一行开始点，就只需要保证不共列和不共斜线就行，然后当达到最后一个皇后时，表示前面都合法了，这是一种解法，返回1

![1671782540425](algorithm.assets/1671782540425.png)

在第 i 行中，0-n-1列上每一列都尝试，isValid方法是黑盒检查方法，表示检查 i 行 j 列的皇后是否跟前面 i-1行的皇后不共列不共斜线

![1671782805267](algorithm.assets/1671782805267.png)

先判断是否共列，然后判断y-y，x-x来判断斜率，因为如果一样就表示要么45°要么135°

可以使用位运算进行加速

![1671783018076](algorithm.assets/1671783018076.png)

建立三个变量来做限制，为1就表示这个位置不能放皇后

而判断下一行的左斜线限制，就是用当前选择 或上 左斜线限制，再整体左移一位

而判断下一行右斜线限制，就是右斜线限制 或上 当前选择再右移一位

![1671783292753](algorithm.assets/1671783292753.png)

这个limit就是表示是几皇后问题，则右侧就有几个1，左侧全是0

![1671783446163](algorithm.assets/1671783446163.png)

----

## 哈希函数和哈希表

哈希函数是不随机的，相同的数得到的哈希值相同，不同的输入也可能导致相同输出(哈希碰撞)

![1671864678959](algorithm.assets/1671864678959.png)

如果输入值经过 f 哈希后得到的值在 S 上均匀分布，则 %m 后的值就在 0~m-1上均匀分布

题目：如果一个大文件，里面是无符号整数(范围是0~2^32 -1，即0~42亿+)，总共40亿个数，只给1G内存，找出出现次数最多的数

解答：如果我们用单纯的哈希表key value来对应数和出现次数，会出现内存不够，因为一个key和一个value分别要4B，就算不计算哈希表内部消耗，也可能要到320亿B，即32G。

但是实际情况不一定会是最差情况，同样的数可能多次出现，这时候我们就可以使用哈希函数

![1671865153506](algorithm.assets/1671865153506.png)

得到的m1，m2数范围都是0~99，对应发送到几号文件，相同的数一定发送到同一个文件中，不同的数也会在种类上均匀分到100个文件中(哈希函数的离散性，均匀性)

然后我们在每一个小文件中使用哈希表，就可以做到让原来的32G%100，每一个小文件中再来找到最大的出现次数，最终再统一比较，可以保证不爆内存

不用管碰撞，因为我们在小文件中是用最初的数来做哈希表

![1671865487567](algorithm.assets/1671865487567.png)

**哈希表的实现**

相当于一个数组接上链表

![1671865609907](algorithm.assets/1671865609907.png)

这样就要考虑到数组长度问题，考虑到扩容问题，即设置条件，假如一条链已经到了长度6，根据哈希函数的均匀分布，可以认为其他链也基本到达长度6，此时扩容，我们可以把表扩容到34，每个数重新%34进行计算哈希值

此时我们估算代价，计算哈希函数是O(1)，但是这是一个大常数，%34也是O(1)，在链表中寻找这个记录的时候，如果链表长度为k，则是O(k)，如果保证链表不是特别长，则就是O（1），但是扩容代价则是O(logN)，总共有N个字符串，而每次扩容都会重新计算哈希值，所以每次扩容有O(N)的计算代价，所以总共扩容代价为O(logN*N)，而均摊到每一个数的扩容代价，则是除以N，即O(logN)，逼近O(1)

所以哈希表在使用上可以认为增删改查都是O(1)，但是理论上是O(logN)

----



![1671866545801](algorithm.assets/1671866545801.png)

![1671866669525](algorithm.assets/1671866669525.png)

![1671866721943](algorithm.assets/1671866721943.png)

没有删除行为时，我们只需要保证得到一个随机的0~25的数，即可随机的到一个key

如果有删除行为，因为哈希表中实际上是不连续的，如果我们直接删除，则会出现很多个空洞，每次getRandom时可能就会取到空洞，解决办法是，我们拿map2中的index的最后一个，去填上即将删除的那个map1中的。

例如要删除D-3，将25对应的Z，在map1中更新为Z-3，删除D-3，再删除map2中的25-Z，再更新3-Z即可，这样我们取随机数只需要改为0~24

![1671867101302](algorithm.assets/1671867101302.png)

![1671867143972](algorithm.assets/1671867143972.png)

----

**布隆过滤器**

![1671867195940](algorithm.assets/1671867195940.png)

假设有100亿个url，每个url为64Byte，在这个系统中，用户使用一个urlx时，要判断是否在这个100亿个url之中(黑名单)，只有增加和查询操作

这里我们可以使用HashSet，就是没有value的HashMap，但是每个都加进去肯定内存爆炸，而我们可以使用布隆过滤器

布隆过滤器是极大减少内存要求，但是可以允许一定的失误率

![1671867641688](algorithm.assets/1671867641688.png)

它不会出现把黑名单中的内容误放，只可能出现把正常内容当成黑名单中的内容的情况，但是可以认为调整概率，只是失误率不可避免。

使用布隆过滤器先了解 位图，bit arr 或者叫 bit map

![1671867868961](algorithm.assets/1671867868961.png)

整型数组，每个占用4字节，32bit，long类型，8字节，64bit，而使用bit类型数组，则每个占用1bit，100个则是100/8个字节

![1671867957417](algorithm.assets/1671867957417.png)

首先申请一个长度为10的整型数组，可以表示长度为320的bit类型数组

![1671868074405](algorithm.assets/1671868074405.png)

178/32表示第几个数里面包含了178bit，而178%32，则是查看这个数中第几个bit表示的是178位bit

这个数右移 bitIndex位，则第178位bit的信息就在这个数的最右侧位置，再将它和1进行 与 运算，得到178位状态是1或者0

![1671869160770](algorithm.assets/1671869160770.png)

而布隆过滤器是一个大的位图

假设有m bit，每个url调用k个哈希函数，得到k个值，把对应的位置描黑

![1671869352478](algorithm.assets/1671869352478.png)

这样就建立好了，当urlx进行查询时，将它调用k个哈希函数得到的值，在位图中拿状态，如果全是1，则表示在这个集合之中，有一个不是1，则认为它不在这个黑名单集合中

这里只有k和m的长度不确定，而如果m太小，则输入太多的时候，可能整个位图都是黑的，这时就所有url都是黑名单，因此m开的越大，失误率可以越低，而k是根据m和失误率来确定

![1671869777517](algorithm.assets/1671869777517.png)

![1671870208132](algorithm.assets/1671870208132.png)

----

**一致性哈希原理**

![1671870281733](algorithm.assets/1671870281733.png)

## 有序表 并查集

**岛问题**

![1671884418948](algorithm.assets/1671884418948.png)

感染问题：定义一个函数将每个连在一片的1都改为2，遍历即可

![1671884906646](algorithm.assets/1671884906646.png)

![1671884937185](algorithm.assets/1671884937185.png)

----

**并查集**

并行算法解决岛问题，先了解并查集结构

![1671888391034](algorithm.assets/1671888391034.png)

issameset方法是判断两个集合是否相同，union是合并两个集合，有很多结构可以做到，但是并查集可以非常快

并查集维护每个集合中的数有个向上指针，最初都是指向自己，合并就是把另一个的最终的向上指针接到另一个集合中

而判断集合是否相同就是看代表元素是否相同，代表元素就是每个集合的向上指针最终指向的那个元素

![1671888903402](algorithm.assets/1671888903402.png)

![1671889018482](algorithm.assets/1671889018482.png)

合并是少的顶直接挂在多的顶上

就是一个往上指的图结构，而并查集中的重要优化是：向上找最终的顶部是可以优化的

如果某个链过长，那么查询过程十分长，所以我们在查到最终顶部时，把之前经过的每个节点的顶指针直接指向顶部

![1671889201750](algorithm.assets/1671889201750.png)

![1671889256563](algorithm.assets/1671889256563.png)

用HashMap来做，维护三个表，用fatherMap来表示父节点的对应关系

![1671889404573](algorithm.assets/1671889404573.png)

并查集初始化要求样本都给予

![1671889535921](algorithm.assets/1671889535921.png)

![1671889748092](algorithm.assets/1671889748092.png)

findHead包含扁平化优化，优化查询过程

----

当我们理解并查集后，就可以开始讨论并行算法解决岛问题

![1671890274806](algorithm.assets/1671890274806.png)

假设有这样的二维数组，单独看是只有1个岛，从虚线分开后，还是用感染过程看，左边是2个岛，同理右侧也是2个岛，这样的话我们需要一个合并逻辑来合并

我们把初始感染位置记为A，找到每次感染的边界位置，记录为从A点感染来的

![1671890452350](algorithm.assets/1671890452350.png)

同理右侧也是这样，收集左侧边界的信息

![1671890495314](algorithm.assets/1671890495314.png)

然后进行合并，一共有4个边界点，ABCD，首先各自为一个集合，然后把边界相碰的两个进行查询是否一个集合，不是则合并，合并后岛屿数量减一，一开始A和C合并，总共3个岛，然后继续合并。

这样做就比单独一个CPU去做更快，分为两个CPU去做一个任务再合并

多个CPU同样逻辑，不断合并

----

## KMP

![1671890779593](algorithm.assets/1671890779593.png)

暴力解法就是尝试每一个开头进行匹配，但是时间复杂度较高，为O(N*M)，N和M分别为两个字符串长度

我们看到一个字符串，当前字符k所表示的信息是它前面的字符串中，前缀和后缀相等的最大长度

![1671892581912](algorithm.assets/1671892581912.png)

所以k的信息是3，不能取到整体

![1671892645569](algorithm.assets/1671892645569.png)

而这个信息，我们是要对 str2 的每个字符都求信息

开头为-1，第二个字符的信息，因为前面只有一个字符，不能取整体，所以为0

![1671892915213](algorithm.assets/1671892915213.png)

有了next数组后开始加速

str1 从 i 位置开始和 str2 比对，直到x 和 y 比对时第一次出现不同，本来应该跳回去重新比对，但是KMP中，str2从Y跳回到Y对应信息的前缀的下一个位置

![1671893212953](algorithm.assets/1671893212953.png)

再在str1中标记一个 j 位置，代表str2中信息对应的后缀的第一个字符的位置，然后将str2滑动到这个位置来

![1671893312980](algorithm.assets/1671893312980.png)

然后X再继续跟前缀的下一个比对

![1671893543459](algorithm.assets/1671893543459.png)

![1671895183646](algorithm.assets/1671895183646.png)

复杂度为O(n)

![1671895914336](algorithm.assets/1671895914336.png)

如果 i-1 的信息位置对应的字符跟 i-1 位置的字符一样，则 i 的信息就是 i-1 的信息 +1

![1671896105113](algorithm.assets/1671896105113.png)

而如果不一样，则从 i-1 的信息对应的位置开始往前跳

![1671896342644](algorithm.assets/1671896342644.png)

比如这里就是，如果e和？不同，则从e开始看它的信息，看s和？是否相等，此时e的信息是3，如果s和？相同，则 i 的信息就是3+1=4，如果s还不等于，那就从s开始往前，s的信息是0，则看第一个字符a和？是否相同

![1671896445975](algorithm.assets/1671896445975.png)

如果相同则 i 的信息是1，如果不相同，因为已经没有了，就是0

![1671896613534](algorithm.assets/1671896613534.png)

cn是指拿哪个位置的字符和 i-1 的比，i=2的时候，i-1 的信息是0，也就是拿第1个字符跟 i-1 比，第1个字符就是第0位置

cn也代表当前 i-1 的信息是多少

----

## Manacher算法

![1671947681820](algorithm.assets/1671947681820.png)

暴力解法可以使用双指针遍历每个字符然后往两边进行判断，但是这样的情况无法判断偶数回文

![1671948130866](algorithm.assets/1671948130866.png)

对字符串加上特殊字符进行处理，每个字符再计算，就可以完全找到所有回文串，将找到的个数除以2即可得到答案(向下取整)，特殊字符随便加，可以在原来字符串中出现过

这是经典解法，时间复杂度是O(N^2)，但是我们可以进行加速

先明确几个概念：

- 回文直径和回文半径，就是整个的长度和除以二向上取整
- 做一个辅助数组，把每个回文半径记录下来

![1671948530844](algorithm.assets/1671948530844.png)

- 定义一个变量 R ，记录每次找到回文串的最右侧边界的最大值，每次更新

- 变量 C ，记录每次R更新后的回文串中心点位置

![1671949243478](algorithm.assets/1671949243478.png)

例如到第一个 2 时，回文范围是2~4，R更新为4，C更新为3

1. 当前点的位置没在回文最右边界R的范围内，这种情况只能暴力向左右两侧扩展范围

   ![1671949457064](algorithm.assets/1671949457064.png)

2. 当前点 i 在R内侧，必有中心点C在 i 的左侧，找到左边界L和 i 根据C做对称的 i`点

   ![1671949639219](algorithm.assets/1671949639219.png)

   再将这种情况进行细分(以下都先省略特殊字符方便理解)

   1. i' 得到的回文区域在L-R的内部，此时 i 的回文半径就和 i' 相同

      ![1671950045007](algorithm.assets/1671950045007.png)

   2.  i' 的回文区域有一部分在L-R的外面，此时 i 的回文半径就是 i-R这一段

      ![1671950630583](algorithm.assets/1671950630583.png)

   3. i' 的回文区域刚好和L重合，此时 i 的回文区域有一部分是确定了的，但是还有一部分需要拓展判断

      ![1671950940297](algorithm.assets/1671950940297.png)

      这里就是R的右边如果是k，则就可以拓展

![1671951291822](algorithm.assets/1671951291822.png)

整个循环，每个i最多失败一次，失败复杂度为O(N)，循环内部条件每个都是要么i++要么i和R一起++，最多到N，所以是O(N)

![1671952229407](algorithm.assets/1671952229407.png)

这个方法是加特殊字符

![1671952485114](algorithm.assets/1671952485114.png)

for循环里面第一句是处理不用验证的区域，用min是求至少的

while循环是把所有情况都往外面扩展，就算遇到不用扩的情况，也只会失败一次

最后是求得最大得回文半径-1就得到最大回文串长度

----

## 滑动窗口、单调栈

![1671953169677](algorithm.assets/1671953169677.png)

窗口运动有左边界和右边界，L不能超过R，任何一个时刻可以选择让L动或者R动

**讨论迅速获得窗口内最大值和最小值问题**

维护一个双端队列，即可以从头进也可以从头出，可以从尾进也可以从尾出，把窗口内得值的下标放里面，规定窗口内的最大值都在双端队列的头

遇到比前面的数大的数，就把之前的数弹出，弹出的数不找回

![1671954063928](algorithm.assets/1671954063928.png)

注意，这里存的都是下标，但是比较大小是比的对应位置的数

![1671954136657](algorithm.assets/1671954136657.png)

遇到相同也要弹出，严格单调

当把L进行移动时，如果窗口内出去的数刚好是双端队列头部的数，就直接弹出，如果不是就不管

**双端队列维护的信息是，如果窗口中淘汰值了，那么谁会继续成为最大值**

双端队列更新的代价是O(N)，单次的平均代价就是除以N，平均代价为O(1)

这道题更简单，已经限定了窗口大小和移动轨迹，只要每次记录下每个窗口状态下的最大值

![1671954965223](algorithm.assets/1671954965223.png)

 [剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（Leetcode）](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/213779/mian-shi-ti-59-i-hua-dong-chuang-kou-de-zui-da-1-6/) 本题直接存储数字，不用存储下标，也可以使用优先队列

![1677119586468](algorithm.assets/1677119586468.png)

优先队列： [剑指 Offer 59 - I. 滑动窗口的最大值 - 力扣（Leetcode）](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/solutions/834190/hua-dong-chuang-kou-de-zui-da-zhi-by-lee-ymyo/) 

自由调用的黑盒：

![1671955208316](algorithm.assets/1671955208316.png)

![1671955229403](algorithm.assets/1671955229403.png)

![1671955240479](algorithm.assets/1671955240479.png)

**单调栈**

解决的问题：一个数组中，想得到每一个数 左边离他最近的比他大的，和右边离他最近的比他大的 是哪个数

![1671955361992](algorithm.assets/1671955361992.png)

想要尽可能快速到O(N)

经典方法O(N^2)，每次来到一个位置进行遍历

![1671955535632](algorithm.assets/1671955535632.png)

维护一个栈，保持单调性，遇到不符合单调性的就要弹出，每次弹出的时候，弹出的数的信息就生成了，左边最近最大就是当前栈顶，右边最近最大就是现在遇到的这个数

弹出就不返回，直到遍历到最后，此时将栈中剩下的都弹出来生成信息，此时他们右边最近最大都没有

有重复值也可以，栈中存集合，相同的放一起

![1671956192830](algorithm.assets/1671956192830.png)

每次弹出，先生成集合最前面的数的信息，而需要取右边最近最大时就先取的是集合中的最后一个

----

![1671956346284](algorithm.assets/1671956346284.png)

此题漏了一个条件，正数数组，累积和是累加和

此题解法：每个数找到它的子数组中，它自己必须是最小值，可能很多个子数组，找到累加和最大的那个

就是把每个数做单调栈，找每个数左边最近最小和右边最近最小，这是它扩展不到的位置，中间全部是扩展的到的，而且累加和肯定最大，因为是正数数组f

----

## 树形dp套路

![1671956981303](algorithm.assets/1671956981303.png)

![1671957042657](algorithm.assets/1671957042657.png)

树形dp的题可以根据头节点参与或者不参与进行分类

![1671958179502](algorithm.assets/1671958179502.png)

三种情况取最大值

![1671958344466](algorithm.assets/1671958344466.png)

![1671958371725](algorithm.assets/1671958371725.png)

![1671958563192](algorithm.assets/1671958563192.png)

----

![1671958573419](algorithm.assets/1671958573419.png)

![1671959081878](algorithm.assets/1671959081878.png)

分为头节点参与或者不参与的情况

参与的情况就是，直接子节点不来的情况下的整棵子树的最大快乐值

头节点不参与，则是0+每个子节点的子树的两种情况的最大值相加

![1671959193941](algorithm.assets/1671959193941.png)

![1671959278172](algorithm.assets/1671959278172.png)

一开始的lai和bu，都是自己，然后循环每个直接下级

x来的时候加上直接下级的不来，x不来的时候加上下级来或者不来的最大值

## 二叉树Morris遍历

![1671959393402](algorithm.assets/1671959393402.png)

![1671959457339](algorithm.assets/1671959457339.png)

一般代码中没太高要求就不用这个，因为较其他代码更复杂一点

实际上是利用原树底层节点中的大量空闲指针实现，也叫做线索二叉树

![1671959850630](algorithm.assets/1671959850630.png)

一个节点如果有左树，就一定出现2次![1671959977126](algorithm.assets/1671959977126.png)

最普通的遍历就是这种情况

![1671960085645](algorithm.assets/1671960085645.png)

打印语句放在123，分别代表先序中序和后序

![1671960155515](algorithm.assets/1671960155515.png)

递归版本一个节点要回到3次

![1671960263922](algorithm.assets/1671960263922.png)

![1671966230184](algorithm.assets/1671966230184.png)

总代价逼近O(N)

修改成先序遍历：

![1671966577924](algorithm.assets/1671966577924.png)

![1671966594856](algorithm.assets/1671966594856.png)

中序就是把出现两次的节点，第二次再打印

![1671966726078](algorithm.assets/1671966726078.png)

后序遍历就换成能回到自己的那个节点，第二次到达时，逆序打印左树右边界，而只经过一次的什么都不做，然后最后单独逆序打印整棵树的右边界

而逆序操作，其实就是单链表的逆序操作，先逆序把右指针全部指回去，打印完再逆序回原样

![1671967499409](algorithm.assets/1671967499409.png)

![1671967551874](algorithm.assets/1671967551874.png)

----

如何判断一棵树是否是搜索二叉树？

就是在中序遍历的过程中，一直是升序

![1671968515023](algorithm.assets/1671968515023.png)

如果题目要求是必须要做第三次信息的强整合，就是要完左树信息，要完右树信息，再回到头节点做强整合，那么就是使用二叉树的递归套路是最优解

如果题目不需要第三次信息的强整合，比如那些先序中序遍历，依次判断这些事，就不一定用二叉树的递归套路，最优解是morris遍历

----

## 大数据题目

![1671968890804](algorithm.assets/1671968890804.png)

![1671968946019](algorithm.assets/1671968946019.png)

可以使用哈希函数，或者位图来做

如果条件再限制为3KB

我们使用无符号整型数组来存，一个整型4字节，3KB/4，取最近的2的某次方的结果，是512，而题目数据是0~2^32-1，我们就可以将2^32个数平分到512个位置上

![1671969733572](algorithm.assets/1671969733572.png)

平分后，每个位置表示当前区域的数出现了多少次，40亿个数，每个数出现的时候，x/8388608 就得到该分到哪个区域，将这个区域的词频++，因为我们的范围是42亿多，而输入只有40亿，总有在一个范围内的词频不会达到8388608个，再在这个范围内，再分成512份再来遍历40亿个数，周而复始就能知道哪个数是没出现的

这是利用词频统计一定会不够的情况来判断

如果只能利用有限几个变量，怎么找到一个没出现过的？

使用二分，某一侧如果满的话，就会是2^32/2个词频统计，一定有一个不满，继续二分直到范围是1，最多遍历32次这个文件

----

![1672817235702](algorithm.assets/1672817235702.png)

利用哈希函数或者布隆过滤器都行

这里利用堆的技巧，原理还是通过哈希函数将海量文件分到小文件里，一种重复url只会出现在一个文件里，每个小文件统计词频(哈希表)，每个小文件做出top100后，用堆的技巧来统计总共的

![1672817584110](algorithm.assets/1672817584110.png)

三个小文件的堆顶拿出来，单独做一个大根堆，每次弹出堆顶，然后去看这个堆顶对应的文件，把他的下一个又放到堆里面去

![1672817686452](algorithm.assets/1672817686452.png)

----

![1672817740381](algorithm.assets/1672817740381.png)

还是可以使用哈希函数分流，这个很万能

这个可以用位图做，本来位图只能表示一个数出现过或者没出现过，但是可以用两个位来表示这个数的出现状态

![1672817944508](algorithm.assets/1672817944508.png)

范围是0~2^32 - 1，每个数用两个bit来统计的话，就是2^32 * 2 bit，兑换字节除以8，刚好1G内存

而找到中位数，也是利用范围统计的技巧

![1672818250210](algorithm.assets/1672818250210.png)

如果只有10KB，我们能有多大的无符号整数数组，就是除以4B，大概2500长度，看看跟2的几次方比较接近，2048比较接近，所以数组长度定为2048，我们的范围是2^32，等分为2048，肯定能分完，然后遍历这些数，某个数属于某个范围就把那个范围++，比如11，输入0号范围，就arr[0]++，然后我们要找中位数，就是找第20亿个数左右的，如果前面已经统计到arr[499]时已经有18亿个数了，那么后续肯定中位数在arr[500]这里，然后再在arr[500]里面重复这个步骤

![1672818783144](algorithm.assets/1672818783144.png)

----

![1672818870975](algorithm.assets/1672818870975.png)

![1672819544588](algorithm.assets/1672819544588.png)

n先右移31位，符号位到最右边了，和1进行与运算，此时0正1负，与1进行与运算，然后调用flip函数取反，做到传入n是非负数就返回1，n是负数返回0

getMax方法把 if else 替换为互斥条件相加，总有一个为0，但是这个方法有个问题，a-b可能溢出，就会出错，但是我们要理解互斥条件相加的思路

所以用下面这个方法来考虑溢出

![1672819872616](algorithm.assets/1672819872616.png)

返回a 有两种情况，一种是a和b符号相同，不会溢出，a-b>0，第二种是ab符号不同，a>0，所以returnA就是两种返回a的条件

----

![1672820246816](algorithm.assets/1672820246816.png)

![1672820291104](algorithm.assets/1672820291104.png)

2的某次幂，就是二进制只有一个1，所以这题只需要把最右侧的1取出来，跟原来数比较是否一样就行

还有方法是，如果x只有一个1，那么我们x-1就会把这个1给打乱，此时让x & (x-1)一定==0

![1672820453776](algorithm.assets/1672820453776.png)

![1672820587720](algorithm.assets/1672820587720.png)

判断是否是4的次幂就是先判断是否只有一个1，然后再跟0101010...进行与运算，如果不等于0就表示是4的次幂，因为4的次幂的1都在0，2，4，8这些位上

----

位运算解决两数之加减乘除

![1672820682334](algorithm.assets/1672820682334.png)

![1672820800720](algorithm.assets/1672820800720.png)

异或运算，就是无进位相加，而求与运算，就是两个数的进位信息，而与运算向左移动一位，就是完全的进位信息

![1672820861526](algorithm.assets/1672820861526.png)

所以这两个相加就行，然后再继续把这个异或结果和进位结果计算他们的异或结果和进位结果，不断进行，知道没有进位信息了，此时的无进位相加的结果就是答案

![1672821093276](algorithm.assets/1672821093276.png)

![1672821270444](algorithm.assets/1672821270444.png)

任何数的相反数就是他自己取反然后+1，所以减法可以用a+ (b的相反数) 来做

![1672821378472](algorithm.assets/1672821378472.png)

乘法跟普通乘法一样

![1672821460128](algorithm.assets/1672821460128.png)

然后累加就行

看图得到，每次会加上上次计算的0，本次计算会多一位，所以a要左移

![1676948227413](algorithm.assets/1676948227413.png)

![1672821568592](algorithm.assets/1672821568592.png)

b&1是看最后一位是不是0，如果是0，那么res就不加，然后a左移一位，b右移一位

![1672821708227](algorithm.assets/1672821708227.png)

然后b的最后一位是1，res+a，直到b全部移完

而a除以b，我们先让b尽可能左移，但是不能超过a，然后让a-b

![1672822310809](algorithm.assets/1672822310809.png)

其实就是乘法的逆运算，我们的乘法是让1的位置左移进行相加，比如现在00101 * 01100，所以我们分别左移两位和3位得到0010100和00101000，再相加得到结果是0111100，那么我们想除回去，想用这个结果除以0000101，那就先让这个0000101左移到不能再左移，此时是0101000，那么我们肯定可以知道，这个第六位的1(最左的1)，肯定在原来乘的那个数上是个1(因为我们就是在这个位上有1，才能乘，然后相加)，所以我们把这个0101000减去得到0010100，然后再左移到不能左移，再减去，就是乘法逆运算除法

![1672822627034](algorithm.assets/1672822627034.png)

**补充大数据求余方法：**

1. 循环求余
2. 快速幂

 [剑指 Offer 14- II. 剪绳子 II - 力扣（Leetcode）](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solutions/106190/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/) 

----

## 暴力递归到动态规划

给出一个整数N>1，代表有N个位置，一个整数S，范围是1-N，机器人一开始就在S位置上，机器人要去e位置，e的范围也是1-N，而机器人必须走 k 步情况下，只能往左走或者往右走，不能不走，比如走到N，只能往N-1走。而现在必须走k步的情况下，从S走到e，有几种方法？

![1672987895752](algorithm.assets/1672987895752.png)

![1672988053194](algorithm.assets/1672988053194.png)

这是暴力递归方法，直接把条件列出来进行递归

![1672988401108](algorithm.assets/1672988401108.png)

暴力递归就是会重复计算已经计算过的，如果我们有一个表结构，记录已经存在的结果，就可以节省很多时间，用空间换时间，从这里我们可以知道，只要这个可变参数确定了，那么不管是谁调用，结果都一样

这种情况就适合改成动态规划，无后效性的规划

递归的第一步优化是**记忆化搜索**

2个参数，肯定是二维数组，判断参数取值范围

![1672988720266](algorithm.assets/1672988720266.png)

![1672988787642](algorithm.assets/1672988787642.png)

用了缓存，肯定有建立缓存过程，修改一下就行

![1672988910599](algorithm.assets/1672988910599.png)

原始递归，因为机器人只能往左右走，可以认为是一个高度为 k 的二叉树，最坏情况下是O(2^k)，而修改完的版本，是O(k*N)

下一步，我们将其修改为**动态规划**

![1672989550912](algorithm.assets/1672989550912.png)

我们根据原来的递归函数，来判断这个表格的结果，行是还剩几步，列是当前位置。首先第一步，当res==0时，就是终止条件，只有到达k=4位置时返回1，其他都是0，然后我们可以知道，k属于1-N，所以第一列全部无效，然后看第二个递归条件，找边界条件，可以知道，当在1位置的时候，依赖的结果是它右上角格子的结果，然后依次类推看剩下的递归条件，就可以完全把这个表格直接写出来了。这就是**严格表结构的动态规划**

它跟记忆化搜索不一样，记忆化搜索只是缓存，而严格表结构要纠结位置依赖的顺序

因此我们可以看到，每个格子的求解时间都是O(1)，所以整个时间复杂度是O(k*N)

![1672989907790](algorithm.assets/1672989907790.png)

----

给出一个正数数组，里面每个位置代表一枚硬币上的面值，有可能有重复，如果给你一个值，请求出组成这个值最少用几枚硬币，不能重复选择相同位置的硬币

![1672990012468](algorithm.assets/1672990012468.png)

这种模型是 **从左往右尝试模型**

![1672990761823](algorithm.assets/1672990761823.png)

index是当前位置，rest是还需要多少钱才达到目标钱数，最终这个方法返回是最少需要的硬币数量

当rest>0，但是已经到数组结尾了，说明不能得到这么多钱了，返回-1无效解，如果还剩下硬币，那么久开始选择，p1是不选择当前硬币，p2Next是选择当前硬币时，后续的情况，所以进行判断

![1672991087885](algorithm.assets/1672991087885.png)

**下一步，改成记忆化搜索**

做个二维表，-1表示算过，是无效解，所以用-2表示没算过

![1672991324492](algorithm.assets/1672991324492.png)

![1672991560432](algorithm.assets/1672991560432.png)

![1672991567410](algorithm.assets/1672991567410.png)

**下一步改为 严格表的动态规划**

通过递归函数，我们可以知道他们的依赖关系，应该从下往上填表，从左往右填表

![1672991970773](algorithm.assets/1672991970773.png)

填好初始条件后，我们直接把递归过程复制到这个循环当中来改

![1672992151944](algorithm.assets/1672992151944.png)

这类106行应该要改else

![1672992354538](algorithm.assets/1672992354538.png)

----

之前的绝顶聪明的题，一开始几个数字，两个人只能从最左或者最右拿牌，看谁最后拿到的牌分数最高，要考虑当前拿了这张牌后对面是否会拿到大牌

![1673003999042](algorithm.assets/1673003999042.png)

当时是用的在一个范围内进行尝试，如果先手最优分是多少

![1673004133121](algorithm.assets/1673004133121.png)

![1673004158672](algorithm.assets/1673004158672.png)

对手一定会给你最差的

**修改为动态规划**

![1673004342759](algorithm.assets/1673004342759.png)

主函数就是在范围内的先手和后手获得得最高分的最大值就是获胜者

两个函数，两张表，i，j取值都是0-length-1

先找主函数需要得到的结果的位置，是0行的length-1位置

![1673004562784](algorithm.assets/1673004562784.png)

因为是正方形表，范围尝试模型，是0-length-1，表的左下方是无效的，因为不可能出现1-0范围

下一步改basecase

![1673004708270](algorithm.assets/1673004708270.png)

接下来看普遍位置是怎么依赖的

![1673004936821](algorithm.assets/1673004936821.png)

分析可以得到出，f表的普遍位置是s表对应位置的左边和下边，而s表也是在f表对应的左边和下边，所以可以得知，f表的对角线可以推出s表的倒数第二条对角线，而s表的对角线可以推出f表的倒数第二条对角线，以此类推上去

**范围上尝试通常看对角线**

![1673005123044](algorithm.assets/1673005123044.png)

----

**改动态规划一定要画图才行！**

现在有一个棋盘，有一个马，开局在(0，0)位置，要去(a，b)位置，一定要走k步，跳到(a，b)的位置的方法是多少种

![1673005661198](algorithm.assets/1673005661198.png)

注意棋盘的范围是x是0-8，y是0-9

![1673005992869](algorithm.assets/1673005992869.png)

假设现在到a点了，只需要一步就可以走到那个需要到达的点了，那我们到a点的函数就该写成(ax，ay，step-1)

总共有8个这样的位置，这种算是逆推

**修改动态规划**

这里三个参数，是三维表

step是这个体的高度，看条件可以知道，每一层都是依赖下一层，那么从第0层开始，可以推第1层，第1层可以推第二层

![1673007166156](algorithm.assets/1673007166156.png)

![1673007361783](algorithm.assets/1673007361783.png)

![1673007399059](algorithm.assets/1673007399059.png)

getValue防止越界

----

给出两个数代表行和列，再给出一个n和m，代表人的位置，可能是越界的，再给出一个参数 k ，人只能从上下左右走动，如果越界代表人死了，那么人活下来的概率是多少

我们可以先算人活下来的方法数有多少

![1673008039017](algorithm.assets/1673008039017.png)

然后我们知道，不考虑人死的情况，可以走4^k次方种方法，那么用活下来的方法数除以它即可

![1673008475576](algorithm.assets/1673008475576.png)

gcd是求最大公约数

修改为动态规划也是一样的，高层只依赖于低层

![1673008567389](algorithm.assets/1673008567389.png)

----

给出一个正数数组，数组内无重复值，一个位置的值代表一个面值的货币，可以重复使用一个位置的货币，如果我需要找出1000，请问有多少方法

![1673008847791](algorithm.assets/1673008847791.png)

这是标准的**背包从左往右尝试模型**

这里的尝试过程是暴力遍历所有情况

![1673010696538](algorithm.assets/1673010696538.png)

**修改为动态规划，二维表**

![1673011109336](algorithm.assets/1673011109336.png)

![1673011326297](algorithm.assets/1673011326297.png)

当rest等于8，index=1时，拿的是5块钱那个，一开始拿0张，就是他下方，第二次拿1张，要-5

依赖的是根据当前货币，挑出的某些位置 ，枚举后累加，如果不优化这个枚举行为，那么代码很好写

整体顺序从下往上

![1673011926949](algorithm.assets/1673011926949.png)

这里有枚举行为，总共时间复杂度是O(N*aim^2)

![1673012164745](algorithm.assets/1673012164745.png)

本行左边一个位置其实已经把前面的加了，所以？的位置就是x+a即可

![1673012615123](algorithm.assets/1673012615123.png)

![1673012686221](algorithm.assets/1673012686221.png)

不越界才能加

**从尝试递归-->记忆化搜索-->严格表的动态规划-->精致优化的动态规划**

尝试的过程中，不要让代表状态的可变参数突破0维，最好就是一个整数，如果上升到数组，那就很复杂了，可变参数的个数也要尽量少

----

## 有限状态自动机

确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：

有一种特殊的状态，被称作「初始状态」。
还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。

一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。

 [剑指 Offer 20. 表示数值的字符串 - 力扣（Leetcode）](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solutions/372095/biao-shi-shu-zhi-de-zi-fu-chuan-by-leetcode-soluti/) 

 [剑指 Offer 20. 表示数值的字符串 - 力扣（Leetcode）](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solutions/278913/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/) 

----

## 平衡二叉树

有序表的所有操作都是O(logN)级别的

![1673241885204](algorithm.assets/1673241885204.png)

红黑树、AVL和SB树时间复杂度相同，都是属于平衡搜索二叉树系列，跳表跟这三种类型不同，是单链表改写的

**二叉搜索树的概念**

二叉搜索树又称为二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树：

- 若它的左子树不为空，则左子树上所有结点的值都小于根结点的值。
- 若它的右子树不为空，则右子树上所有结点的值都大于根结点的值。
- 它的左右子树也分别是二叉搜索树。

可以默认搜索二叉树上没有重复值，因为就算遇到重复值，我们可以在一个节点上的值做链表

搜索树的删除，就是找到这个删除的节点，并且记录它的父节点，然后删除就行，假设这个节点还有孩子节点，就让这个孩子节点替代它的位置就行，直接删掉然后让父节点指向它的孩子节点

而如果两个孩子都全，则比较麻烦

![1673242614758](algorithm.assets/1673242614758.png)

如果要删除 3 这个节点，就要么将它左树最右节点替换上来，要么是右树的最左节点

![1673243949369](algorithm.assets/1673243949369.png)

把4的右边子树接到6这里，然后把4替换3

其他的红黑树，AVL,SB树都是这样增删改查

现在的搜索二叉树，没有平衡性，时间复杂度不能维持到O(logN)

严格的平衡性：左树跟右树的高度差不能超过1

而这里我们不要求严格，只要求任何一个节点左树右树相差不多，这样也能做到O(logN)

**AVL树**

平衡二叉树，全称为平衡二叉搜索树
它是由苏联数学家Adelson-Velsky 和 Landis提出来的，因此平衡二叉树又叫AVL树
平衡二叉树的定义是一种递归定义，要求每个节点都具有以下特性：

可以是一棵空树
左子树和右子树高度之差的绝对值不超过1（左右子树的高度差可以为0、1和 -1）
左子树和右子树均为平衡二叉树

**搜索二叉树，如果带有左旋和右旋，则是一种自平衡的搜索二叉树，而AVL树，是实现的怎么用这个左旋和右旋的操作**

![1673244480425](algorithm.assets/1673244480425.png)

**红黑树也是这样，但是红黑树有关于自己的平衡性定义，在这种定义下，怎么去实现左旋右旋，SB树同理**

![1673244597869](algorithm.assets/1673244597869.png)

左旋是往左边旋转，C为头节点了，C的左节点比A大，比C小，所以可以成为A的右孩子

![1673244690551](algorithm.assets/1673244690551.png)

右旋同理，B的有孩子比A小比B大，所以成为A的左孩子

现在有个问题，AVL怎么查到自己的不平衡的？

**AVL的增删改查和搜索二叉树相同，但是每次增加或删除一个节点，会从加入的节点开始，往上每个节点查一遍平衡性**

但是删除节点时会遇到一种情况，如果删掉的这个节点左右孩子都有

![1673244938768](algorithm.assets/1673244938768.png)

此时把6替换给5，7接上A，这时从7节点开始查，查7，8，6为头节点的树是否具有平衡性，就是从替换的那个节点的父节点开始查

**那么现在到底具体怎么检查呢？有几种被破坏的情况：**

1. LL型

   左树的左边过长，做个右旋就行

2. RR型

   右树的右边过长，做个左旋

   ![1673245243088](algorithm.assets/1673245243088.png)

3. LR型

   左树的右边过长，调整的时候让那个过长的那部分的头节点旋转成头部就行了，就可以先把X左旋上来，再右旋上去

![1673245344999](algorithm.assets/1673245344999.png)

4. RL型同理，先右旋上去，再左旋上去

   ![1673245514099](algorithm.assets/1673245514099.png)

那么我们怎么确定是这四种类型中的哪一种？

![1673245590357](algorithm.assets/1673245590357.png)

判断左右树的高度，如果右树更大，右树的右树不为空，说明RR型，单次左旋，否则就是RL型，双次调整

![1673250592484](algorithm.assets/1673250592484.png)

----

![1673250735490](algorithm.assets/1673250735490.png)

**SB树**

![1673251319766](algorithm.assets/1673251319766.png)

SB树也有4种调整情况

LL型：左边子树的子树大小，大于右边子树的大小

![1673251624230](algorithm.assets/1673251624230.png)

先做一个右旋，然后再去看孩子变了的节点，进行一个递归判断是否是需要调整的

![1673252426529](algorithm.assets/1673252426529.png)

第三步，发现L的孩子节点也变化了，所以再检查L的

RR型态也是这样，左旋就行，然后递归检查

然后LR型态也是，先左旋后右旋，让那个节点到头部，再递归判断那些孩子变化了的节点

![1673252804422](algorithm.assets/1673252804422.png)

![1673252820086](algorithm.assets/1673252820086.png)

![1673252853436](algorithm.assets/1673252853436.png)

![1673252922036](algorithm.assets/1673252922036.png)

![1673252951066](algorithm.assets/1673252951066.png)

红黑树也是打标签，SB树是size标签，而AVL树是height标签，红黑树就是每个点不是红就是黑

**红黑树**

红黑树的叶节点，指的是最底层的空节点

头节点和底层叶节点(null)必须为黑

红节点不相邻

每一个cur节点，到它叶节点的每一条路径要求黑节点数量一样

其实这些规定就是，最长的那条路径就是黑红交替的，最短的路径就是全是黑节点的，而这两种之间的高度差不会超过两倍

**跳表**

跳表是实现有序表的一种方式，它的Key 一定要求可以比较

指向下级的指针都在链表里，可能有指向多个下级，不止两个

![1673253626495](algorithm.assets/1673253626495.png)

有一个默认节点，它的 key 是默认全局最小，一开始有个指针指向空，

![1673253803925](algorithm.assets/1673253803925.png)

现在有个新节点3，开始随机摇骰子，扔到1则继续仍，同时指针数量+1，直到扔到0，假设扔了两个1，一个0，那么就有3条指针

此时把 3 这个节点加入到默认节点后面，但是默认节点此时只有1个指针，所以需要扩充到跟3节点一样，只有默认节点才会扩充指针，

![1673253958879](algorithm.assets/1673253958879.png)

如果再来了个节点 5，摇出了4层指针，那么默认节点又要扩充，默认节点永远跟着最大的走

然后我们将5这个节点从默认节点的最高层开始看，看看有没有刚刚大于5的节点，没有就直接指向5这个节点，然后看下一层，第二层，然后在遍历过程中，自然能找到小于等于5的最右的节点，就是这个3节点，然后让3节点的第二层的指针指向5

![1673255715783](algorithm.assets/1673255715783.png)

同理看到第一层，也是找到3节点是小于等于5的最右节点，再往下继续

![1673255812826](algorithm.assets/1673255812826.png)

如果再来个4节点，此时他只有2层指针，那么还是默认节点从最高层指针开始找，找小于等于4的最右节点，就是它自己，大于等于4的最左节点是5，但是4节点没有第三层指针，只能往下看，第二层指针时，找到了3节点是比4节点小的最右节点，但是4节点没有第二层指针，此时3节点的指针往下跳，跳到第一层指针，发现还是3节点自身是小于等于4的最左节点，此时4节点有第一层指针，所以挂上它，让4节点的第一层指针指向原来的5，继续往下跳，把第0层的指针也挂上

![1673256079528](algorithm.assets/1673256079528.png)

![1673256270840](algorithm.assets/1673256270840.png)

假设在这种情况下，想加入两层的70这个节点，那么第一次找到最右节点是20，直接跳过了3，10，15，然后70没有第五层指针，所以20往下找，直接到了50，然后发现没有第四层指针，继续往下，直到第一层指针

![1673256351035](algorithm.assets/1673256351035.png)

这就是利用了高度这个索引，跨过了很多步骤

如果是删除节点，那么还是先查找，从最高层开始查找，找到小于50的最右节点，是20，发现不是50，所以20这个节点指针往下一层继续找最右节点。找到了50

删除就是把前面的指针和后面的指针链接一下

----

## 中级班实战题

![1673263693634](algorithm.assets/1673263693634.png)

我们不需要把绳子放在一个不存在的点上，我们就枚举绳子的最右端在每一个点上的情况，那么绳子的左边就会覆盖一些点，这样把所有点都枚举，其中肯定有最多覆盖的那个答案

有点类似贪心思想

![1673263833036](algorithm.assets/1673263833036.png)

![1673264538376](algorithm.assets/1673264538376.png)

比如L=5的情况，此时如果绳子最右端在0位置，对应点是2，绳子左边最长到-3，此时找大于等于某个数的最左位置，来确定这边能覆盖几个点

![1673264681945](algorithm.assets/1673264681945.png)

这里绳子最右端是在2位置时，对应数轴8-5=3，最左是3.大于等于3的最左位置是1号位置对应数轴4，此时8的下标和4的下标2-1，再+1，得到2个数

![1673264777784](algorithm.assets/1673264777784.png)

到9的时候，最左长度能到4，大于等于4的最左就是1号位置的4，此时3-1+1=3个点

这种方法检查了N个点，而每个点的时间复杂度是二分O(logN)，所以总共是O(N*logN)

### 优化为滑动窗口

让绳子左端来位置一个窗口的左边界，R往下面动，不能超过绳长L，

![1673265002126](algorithm.assets/1673265002126.png)

当L是0位置时，R最多来到1位置，因为2位置的8-2=6超过绳长了

![1673265076151](algorithm.assets/1673265076151.png)

然后L往下动，R继续往下

L和R都不会回退，整个复杂度是O(N)

这种题就是可以构建一种单调，不回退的窗口模型

----

### 打表法

![1673265227677](algorithm.assets/1673265227677.png)

普通解法：尝试的方式应该是，尽可能用8的袋子装完，然后再看剩下的能不能用6的袋子装完，如果不行，那就8的袋子-1，不断尝试

![1673275521601](algorithm.assets/1673275521601.png)

**优化解法：**

![1673275211352](algorithm.assets/1673275211352.png)

我们从一个例子可以得知，剩下的苹果数量大于27个的时候，肯定不行，因为27个时，4个6个(或者3个8个)的为24，还剩3个，已经判断过了不行

当我们发现，输入是整数，输出也是整数，那我们可以先用简单暴力做法做，然后查看结果的规律

![1673276088827](algorithm.assets/1673276088827.png)

![1673276117641](algorithm.assets/1673276117641.png)

![1673276239648](algorithm.assets/1673276239648.png)

看规律后得知这几种情况

----

吃草题目，分先手和后手，必须吃，只能吃4的n次方，n从零开始，假设一共有N份草，谁先把草吃完谁赢

假设N=1，先手赢了，N=2，后手赢，N=4.，先手直接吃4的1次方，先手赢

![1673329936745](algorithm.assets/1673329936745.png)

当前先吃掉 base 份草，if 里面的子过程里面，其实原来的先手就变成了后手，所以如果子过程返回的是后手，则说明整个过程是先手赢了

防溢出是可能溢出整数边界

![1673330504321](algorithm.assets/1673330504321.png)

然后再继续打表看规律

![1673330673094](algorithm.assets/1673330673094.png)

----

### 预处理技巧

![1673330788228](algorithm.assets/1673330788228.png)

正常思路是：先假设全是右侧，全部都涂染成G，然后假设左侧一个R，右侧全部是G，不断尝试，比较最小答案

![1673331793897](algorithm.assets/1673331793897.png)

我们可以做一些辅助结构，让一些结果直接取出

开一个数组，记录0~i 范围内有几个R，这样只需要遍历一遍就可以拿到左边有几个R

![1673331870483](algorithm.assets/1673331870483.png)

再开一个数组记录 i ~N-1范围上有几个G，我们需要把 i ~N-1上变成R，就需要查询这上面有几个G

**这就是预处理技巧，直接拿一个结构记录一些答案，然后查询时直接拿结果就行**

这样我们在遍历过程中，来到任意一个点都不需要重新遍历，直接从辅助数组中拿答案即可

----

![1673332113132](algorithm.assets/1673332113132.png)

![1673332313889](algorithm.assets/1673332313889.png)

如果一个n^2的矩阵，它内含的长方形子矩阵的大小是n^4规模的，因为我们可以在矩阵内部随机找两个点作为左上角和右下角，以此确定唯一的一个长方形，而找一个点的代价是n^2，所以总共规模是n^4，而两个点可能重复，也只会重复一次，常数项较小

那么现在我们来找正方形的子矩阵数量级，答案是n^3规模，因为只能先定一个点，然后枚举他作为左上角的边长情况

![1673332709343](algorithm.assets/1673332709343.png)

两个点枚举左上角点的所有情况，再来一个for循环枚举边长，边长的范围应该是看向下或者向右碰到底了

![1673333197150](algorithm.assets/1673333197150.png)

然后里面分别四个for循环遍历每条边是否全部是1，这样时间复杂度就到O(n^4)

所以我们要用预处理来解决这个验证过程：

我们开一个同样大的矩阵数组，每个点记录它右边包括自己有多少个连续的1，再生成一个down数组，记录每个点包括自己在内的下方有多少个连续的1

![1673333391951](algorithm.assets/1673333391951.png)

![1673333460654](algorithm.assets/1673333460654.png)

如果我们要判断[4,5]，边长为3的点的正方形，就只需要先拿出[4,5]的两个辅助矩阵，看他们的1是否都是大于等于边长，如果都成功，则跳到右上角看它的down数组，然后再看左下角的right数组

----

![1673333827465](algorithm.assets/1673333827465.png)

![1673333988508](algorithm.assets/1673333988508.png)

像这种题目，可以直接用二进制来拼凑，因为3个二进制位，我们可以拼出0~7，所以只要我们实现一个函数是等概率返回0或1，那么直接重复3次，就可以等概率得到3个二进制位，就相当于等概率返回0~7，但是现在，我们想要的是0~6，然后+1得到1~7，所以我们直接判断，让得出是7的时候，重新做

![1673334139026](algorithm.assets/1673334139026.png)

![1673334223854](algorithm.assets/1673334223854.png)

如果给出的是13~21，那么同样先改成01发生器，然后求30~59的，就相当于求0~29，然后+30，然后我们只需要5个二进制位就可以求得0~31范围，如果得到的数超过29，直接重做

![1673334348672](algorithm.assets/1673334348672.png)

而第三问，f 函数是p概率0，1-p概率1，那么我们如果随机得到00或11，直接重做，直到得到10或01，因为此时他们的概率相乘

----

### 动态规划

![1673334487843](algorithm.assets/1673334487843.png)

![1673335451207](algorithm.assets/1673335451207.png)

![1673335536341](algorithm.assets/1673335536341.png)

只有一个可变参数，直接改动态规划

![1673335649627](algorithm.assets/1673335649627.png)

----



![1673335682973](algorithm.assets/1673335682973.png)

直接用一个变量记录count记录左边括号和右边括号的数量，遇到左括号就++，右括号--，如果小于0，那么必定不完整

结束的时候，count必须为0，而现在题目是需要添加多少个括号，那么直接用一个变量ans记录，每次count=-1时，让ans++，然后count=0，最后如果count=0，直接返回ans，如果不等于0，那么ans+=count

![1673336046138](algorithm.assets/1673336046138.png)

----



![1673336083846](algorithm.assets/1673336083846.png)

去重就是，如果k=2，那么有0和2的时候不统计2和0，如果有两个0，也只记录一次0和2

直接使用哈希表，把所有数字放进哈希表，遍历的时候找对应差值的数在不在哈希表即可

----

### 贪心

![1673336276875](algorithm.assets/1673336276875.png)

集合中元素不重复，所以放到另一个集合中的值必须是另一个集合中没有的值

![1673336702013](algorithm.assets/1673336702013.png)

当两个集合平均值相同，无法做magic操作

而两个集合平均值不一样的时候，不能从小的集合拿到大的集合

![1673336808602](algorithm.assets/1673336808602.png)

![1673338166337](algorithm.assets/1673338166337.png)

在这种情况，我们应该拿60，让A获得最大程度平均值提升，而B集合最小幅度平均值提升，这样可以更多的进行magic操作，因为这个操作次数取决于两个集合平均值的差值大小

![1673338279959](algorithm.assets/1673338279959.png)

![1673338367325](algorithm.assets/1673338367325.png)

![1673338418736](algorithm.assets/1673338418736.png)

![1673338439588](algorithm.assets/1673338439588.png)

建立hashSet来处理查找想加入的元素是否在平均值小的数组中存在

这里的时间复杂度只有那个sort函数是O(N*logN)，其他都是O(N)

----



![1673338743027](algorithm.assets/1673338743027.png)

这题跟前面思路相同，还是用count记录，count达到的最大值就是最大深度

----

### 动态规划

给出一个字符括号串，请找出里面最长的连续的有效括号子串

![1673340933961](algorithm.assets/1673340933961.png)

这种题目的特征都是，求出每个字符为结尾的情况下的最长连续有效子串长度

左括号结为肯定无效，填0

当我们求 i 位置的值时，肯定前面已经有成功的值了，可以复用结论

![1673341176558](algorithm.assets/1673341176558.png)

当 i 位置时，看 i-1位置，如果是4，那么再往前4个，看是否是左括号，如果是就 i 为6

![1673341251511](algorithm.assets/1673341251511.png)

如果还是右括号，那么肯定是0，有点KMP的思想，

![1673341307071](algorithm.assets/1673341307071.png)

而如果是左括号，还要往前面看一位来推，4位置前面是左括号，所以+2，再看前一位2位置是2，所以再+2

![1673342245927](algorithm.assets/1673342245927.png)

遇到左括号，只需要再往前接一次就行

![1673342352540](algorithm.assets/1673342352540.png)

![1673342360086](algorithm.assets/1673342360086.png)

----



![1673342460662](algorithm.assets/1673342460662.png)

![1673342565314](algorithm.assets/1673342565314.png)

直接在辅助栈里面互相弹出，辅助栈里面保持小到大，再弹回原来栈就是大到小

----

**动态规划**

![1673342622444](algorithm.assets/1673342622444.png)

这是一个明显的**从左往右尝试模型**

就是看当前到达的位置开始，往后能有多少种转化方式

分两种情况：

![1673348525240](algorithm.assets/1673348525240.png)

当 i 位置是0时，转化数量为0

![1673348586957](algorithm.assets/1673348586957.png)

![1673348609648](algorithm.assets/1673348609648.png)

这里第一个终止条件返回1，表示的是到达最后一个字符了，说明前面的转化都成功了，所以返回一种转化情况

![1673348711815](algorithm.assets/1673348711815.png)

![1673348931258](algorithm.assets/1673348931258.png)

----

### 二叉树递归套路

![1673348983830](algorithm.assets/1673348983830.png)

非套路解法：

![1673349284147](algorithm.assets/1673349284147.png)

![1673349389799](algorithm.assets/1673349389799.png)

套路解法：

![1673349577508](algorithm.assets/1673349577508.png)

----



![1673349625106](algorithm.assets/1673349625106.png)

经典套路方法：从右上角开始找，进行二叉树搜索，因为都是有序，所以可以直接排除，如果当前节点大于要找那个节点，那这一列都比他大，直接往左边走

![1673349744177](algorithm.assets/1673349744177.png)

如果越界了，就不存在

复杂度为O(N+M)

----



有一个二维数组，里面全是０和１，０一定在１左边，有可能全是０或全是１，需要返回含有１最多的行

![1673349853923](algorithm.assets/1673349853923.png)

准备一个ｌｉｓｔ，从右上角开始走，找１，直到最左的１，然后记录这一行有多少个１，然后往下走看能不能扩展

![1673350007625](algorithm.assets/1673350007625.png)

每次更新要把原来答案删除，多个就直接加入到ｌｉｓｔ中

----

### 贪心

![1673355645896](algorithm.assets/1673355645896.png)

首先大过滤器判断能否整除，判断当前ｉ位置，如果左右位置都需要衣服，那么就说明ｉ位置衣服过多，ｉ位置至少需要移动左右两边需要的衣服的绝对值之和

如果左右都是正的，则取最大值，因为最大值那个必须移动这么多轮

左负右正，也是最大值

![1673356205124](algorithm.assets/1673356205124.png)

把每个位置的瓶颈求出来，找到最差的那个，满足最差那个的时候，其他的一定满足

![1673356357056](algorithm.assets/1673356357056.png)

**这题也可以做预处理之类的优化操作**

![1673356479227](algorithm.assets/1673356479227.png)

![1673356506845](algorithm.assets/1673356506845.png)

----

###　只关注宏观过程

![1673357591821](algorithm.assets/1673357591821.png)

![1673357748538](algorithm.assets/1673357748538.png)

这种题，不能关注细节，只看宏观，我们只关注左上角和右下角，直接打印这一个边框，然后左上角右下角分别移动，继续打印，直到两者错过

只需要处理三种情况：分别是左上角右下角是竖线，横线，以及普遍情况

![1673357868241](algorithm.assets/1673357868241.png)

![1673357906926](algorithm.assets/1673357906926.png)

![1673357960339](algorithm.assets/1673357960339.png)

主函数

![1673358001180](algorithm.assets/1673358001180.png)

----

![1673358019489](algorithm.assets/1673358019489.png)

同理，还是只需要定义一个框如何变动的函数，然后让两个角缩小

每一个框分边长－１个组

![1673358322289](algorithm.assets/1673358322289.png)

![1673358506679](algorithm.assets/1673358506679.png)

各个组的４个变量相继交换即可，ｉ表示第ｉ组

![1673358639112](algorithm.assets/1673358639112.png)

![1673358662246](algorithm.assets/1673358662246.png)

----



![1673358895019](algorithm.assets/1673358895019.png)

还是一样，宏观过程判断，定义两个点，一开始都在左上角，然后A往右边走，B往下面走，A到最右就往下，B到最下就往右，然后我们定义两个斜线打印的函数，一个是从左下往右上，一个从右上往左下

![1673359161456](algorithm.assets/1673359161456.png)

ｆ为ｔｒｕｅ就从右上往左下打

![1673359200295](algorithm.assets/1673359200295.png)

----



![1673359751149](algorithm.assets/1673359751149.png)

这题从规律看，如果ｎ是质数，那么答案一定是只调用第二个操作得到，是ｎ－１次

如果ｎ不是质数，那么我们假设它是由几个质数因子相乘得到的，那么不管他们怎么组合，总会有个最优解

![1673361467071](algorithm.assets/1673361467071.png)

![1673361593397](algorithm.assets/1673361593397.png)

假设最优顺序就是XYZP，那么肯定是最后有P份XYZ，那么P是质数，所以调用ｐ－１次操作二，那么同理往前面推，调用Z－１次操作二....，最终就是X+Y+Z+P-4

![1673361715947](algorithm.assets/1673361715947.png)

![1673361741035](algorithm.assets/1673361741035.png)

----

### 利用堆

![1673361855003](algorithm.assets/1673361855003.png)

利用堆，遍历一遍建立词频表，用哈希表就可以，然后用大根堆，利用比较器来建立，然后弹出前K个

![1673362024287](algorithm.assets/1673362024287.png)

![1673362137154](algorithm.assets/1673362137154.png)

或者利用小根堆，虽然是小根堆组织，但是存的是目前位置最大的两个，这样堆顶就是一个进入的门槛，每次只有更大的才能进来，然后再调整小根堆，这样比用大根堆更节省空间

----

假设用户需要一种结构，这种结构可以接收用户给的字符串ａｄｄ方法，同时用户可能随时调用一个函数ｐｒｉｎｔTｏｐK

需要这两种的时间代价都不高

**这题不能使用系统提供的堆结构**

如果有重复的值，随便打印一个都对

![1673362616293](algorithm.assets/1673362616293.png)

![1673362681046](algorithm.assets/1673362681046.png)

堆位置ｍａｐ的ｖａｌｕｅ是ｋｅｙ在堆中的位置，这个堆是按词频统计的小根堆，只有ｋ的长度

![1673362836563](algorithm.assets/1673362836563.png)

当A变成２，因为是小根堆，就要ｈｅａｐｉｆｙ调整，对应在堆数组中就是交换位置，更新后堆位置ｍａｐ也要更新

![1673362986022](algorithm.assets/1673362986022.png)

当D进来的时候，因为堆满，又干不过门槛，所以D不能进入，但是堆位置ｍａｐ上记录－１

![1673363041016](algorithm.assets/1673363041016.png)

D进入后，还要进行ｈｅａｐｉｆｙ，然后C上去，D下来

![1673363098416](algorithm.assets/1673363098416.png)

堆上放的是Nｏｄｅ，ｉｎｄｅｘ是目前堆的大小

![1673363202558](algorithm.assets/1673363202558.png)

ｐｒｅIｎｄｅｘ是在堆上位置

如果ｐｒｅIｎｄｅｘ＝－１，表示此时不在堆上，开始分情况，堆满就比较门槛，堆没满就加入

![1673363393647](algorithm.assets/1673363393647.png)

![1666337173736](algorithm.assets/1666337173736.png)

这是大根堆的ｈｅａｐIｎｓｅｒｔ，比较的是自己和自己的父亲节点的大小

![1666337568531](algorithm.assets/1666337568531.png)

这也是大根堆调整

这里有问题，ｈｅａｐｉｆｙ里面调整了位置后，没有更新ｎｏｄｅIｎｄｅｘMａｐ，这题的ｈｅａｐｉｆｙ里面有更新这个表的过程

![1673364319709](algorithm.assets/1673364319709.png)

![1673364352008](algorithm.assets/1673364352008.png)

![1673364364323](algorithm.assets/1673364364323.png)

交换都封装到ｓｗａｐ里面

----



![1673414255873](algorithm.assets/1673414255873.png)

![1673414296327](algorithm.assets/1673414296327.png)

----



![1673414431137](algorithm.assets/1673414431137.png)

![1673414554235](algorithm.assets/1673414554235.png)

开两个栈结构，一个为最小栈，用来存当前最小，如果左边正常栈压入的数比之前的大，那就在最小栈里面还是压最小的值，然后两边同步弹出，如果正常栈弹出栈顶，那么最小栈也要

----



![1673414636978](algorithm.assets/1673414636978.png)

![1673414723992](algorithm.assets/1673414723992.png)

两个栈，两个原则，第一个是如果ｐｕｓｈ栈要倒出元素倒ｐｏｐ栈，那么必须全部都出去，第二点，如果ｐｏｐ里面有元素，那么ｐｕｓｈ就不能倒出到ｐｏｐ里面

![1673414776606](algorithm.assets/1673414776606.png)

![1673414841837](algorithm.assets/1673414841837.png)

队列维护栈结构：用两个队列

![1673414941251](algorithm.assets/1673414941251.png)

如果要新增元素，那就全部放在一个队列里面，直到弹出时，把前一个队列的前面的元素全部放到另一个队列里面，只剩下最后一个，然后弹出，就是栈的后进先出了

![1673415020068](algorithm.assets/1673415020068.png)

**图的深度优先遍历必须用栈，那么可能就会考你只给你队列做深度优先遍历，图的宽度优先遍历必须用队列，就可能只给你栈**

----

### 动态规划的空间压缩技巧

![1673415287979](algorithm.assets/1673415287979.png)

![1673415379085](algorithm.assets/1673415379085.png)

比如一个二维表，要求的是右下角的值，正常情况下我们是把所有都计算出来，然后给出右下角的值，但是实际上，假如一个普遍位置依赖左边和上面的值，那么在第一行只依赖左边，第一列只依赖上面

那么我们只需要先给出第一行的值，然后让他自我更新，直到最后一行

![1673415523524](algorithm.assets/1673415523524.png)

假设依赖的是上一行的多个位置的值，那么可以从右往左更新

![1673415659024](algorithm.assets/1673415659024.png)

如果依赖左边和左上以及上方，那么可以用一个变量来记住左上的值

![1673415755927](algorithm.assets/1673415755927.png)

如果遇到列数太多，可以倒过来，用第一列来自我更新

![1673416819513](algorithm.assets/1673416819513.png)

如果遇到跳转太远了就不能压缩

![1673416924329](algorithm.assets/1673416924329.png)

如果是这种，我们也可以申请３个一位数组来进行滚动更新

----

**双指针压缩数组空间**

![1673417079723](algorithm.assets/1673417079723.png)

![1673420712447](algorithm.assets/1673420712447.png)

这题类似洗衣机问题，不能关注全局到底怎么变化，看当前某个点的情况

![1673420885934](algorithm.assets/1673420885934.png)

左边１０，右边２０，肯定看更小的那个，减去当前自己的大小，就是能存的水量

![1673420957760](algorithm.assets/1673420957760.png)

然后把单个的水量累加

![1673421373968](algorithm.assets/1673421373968.png)

双指针，首先最左和最右肯定是０，然后两个变量记录最左和最右的最大值，开始分别为１０和７，然后ａｌｌ变量记录当前总共水量，首先来到３，此时我们看到３的右侧已经确定了是最大７，而左侧虽然没有遍历完，但是已经是１０比７大，所以３肯定依赖的是７，直接减去就得到４，然后到１１，发现依赖右边，但是比右边大，所以０

![1673421485852](algorithm.assets/1673421485852.png)

此时右侧最大是１１，而L部分的左侧最大是１０，已经确定了，所以１号位置可以结算

----

![1673421605528](algorithm.assets/1673421605528.png)

当然可以用预处理，任意一个前缀的ｍａｘ和任意一个后缀的ｍａｘ都找到，但是可以用更简单的

有限几个变量，时间复杂度为O(N)

![1673421822097](algorithm.assets/1673421822097.png)

首先找到全局最大值，然后如果把他划分为左部分，那么我们可以肯定是的右边部分至少会有第N－１个数，所以有部分只有那一个数的时候，右侧的最大值是最小的

第二种可能性，ｍａｘ划分到右部分，此时必定是０位置在左侧，所以答案是ｍａｘ－ａｒｒ[０]

所以整体流程就是遍历一遍找到最大值，然后最左和最右找到最小值然后相减

----

### KMP

![1673421964316](algorithm.assets/1673421964316.png)

首先看长度是否一样，然后直接让ａ＋ａ，再判断ｂ是否是ａ＋ａ的子串就行

![1673422081435](algorithm.assets/1673422081435.png)

原理就是，在这个ａ＋ａ中，任意长度为５的子串一定是旋转词

----

###　小根堆和从左往右尝试模型到动态规划

给出一个正数数组，每个数代表一个咖啡机的工作效率，每个咖啡机一次只能冲一杯，N个人，每个人喝一杯，如果一个咖啡机前面有人，那么只能等他先喝完，但是可以认为人喝咖啡时间为０，即咖啡冲好就喝完，有一台洗咖啡杯的机器，一次只能洗一杯，每次时间为ａ，咖啡杯不洗，自然挥发也能干净的时间为ｂ，问从这些人开始冲咖啡时，到所有人咖啡杯都干净至少需要的时间

先看怎么冲，维护一个小根堆，里面是二维数据，判断大小是两个数据相加

![1673425204865](algorithm.assets/1673425204865.png)

这个组织方式，也代表哪个咖啡机泡完时间最短

![1673425298524](algorithm.assets/1673425298524.png)

当第０个人选择小根堆第一个，完成时间是２，所以更新咖啡机开始时间为２，所以２，２继续加入小根堆中

利用这种机制选择咖啡机，可以最省时间

![1673425451103](algorithm.assets/1673425451103.png)

而我们得到的这个喝到咖啡的时间的数组，同样也代表着需要开始洗咖啡杯的时间

现在这个数组，只有两种选择，一是用机器洗，二是等待挥发，需要找到最少时间，那么这就是一个从左往右尝试模型

![1673425735095](algorithm.assets/1673425735095.png)

![1673425871923](algorithm.assets/1673425871923.png)

这里的蓝色部分，代表的是如果我喝完咖啡了，但是咖啡机没洗完上一个，那也不能开始洗，如果咖啡机洗完了，但是我还没喝完，也不行，所以找到更大的时间点，＋ａ表示用机器洗，第二个条件是直接挥发，两个条件选最小的

![1673426096738](algorithm.assets/1673426096738.png)

ｐ１是找到当前洗碗这个杯子的时间和洗完剩下所有杯子的时间做比较，谁大选谁

剩下的同理，决定当前杯子选择自然挥发，最终两种情况进行比较

![1673426207470](algorithm.assets/1673426207470.png)

然后改成动态规划，两个可变参数

小根堆建立

![1673426437950](algorithm.assets/1673426437950.png)

![1673426457386](algorithm.assets/1673426457386.png)

改动态规划，ｉｎｄｅｘ范围是０～N－１，ｗａｓｈｌｉｎｅ的最大值估计为每个杯子都放到机器洗，

![1673426817630](algorithm.assets/1673426817630.png)

![1673426832588](algorithm.assets/1673426832588.png)

这个时间不好估计的话，直接准备足够用的表空间就可以

----



![1673426903588](algorithm.assets/1673426903588.png)

数字分为两类，奇数和偶数，偶数中继续分为两类，分别是只有一个２因子的数和包含了４因子的数

![1673427227239](algorithm.assets/1673427227239.png)

![1673427341516](algorithm.assets/1673427341516.png)

当ｂ＝０，那么奇４奇４来是最好的，３个奇最少需要２个这种４因子偶数，所以分ａ＝１和ａ>１两种ｃ的情况

ｂ≠０时，把所有２因子偶数摆在一起，他们能自己凑成４因子，最后一个不能奇数，应该是４因子，然后继续奇４奇４，此时要求ａ＝０时ｃ>=０，ａ＝１，ｃ>=１，ａ>１，ｃ>=ａ，所以统一化简为，ｂ≠０时，ｃ>=ａ

![1673427538602](algorithm.assets/1673427538602.png)

注意还要单独区分ｂ＝１的时候，如果此时只有奇数那也不行，必须有个４因子

----

### 前缀树

![1673939214848](algorithm.assets/1673939214848.png)

经典的前缀树设计，值是放在边上的

根节点是空节点

![1673939667337](algorithm.assets/1673939667337.png)

按照题意，可以使用**深度优先遍历**

![1673939732359](algorithm.assets/1673939732359.png)

![1673939875800](algorithm.assets/1673939875800.png)

java里面，反斜杠是代表转义，所以要用两个斜杠代表一个斜杠，然后因为split函数里有转义和正则匹配，会先将4个斜杠转义成2个，然后进一步理解为1个斜杠，这样才能单独打印出a  b  c

![1673939996791](algorithm.assets/1673939996791.png)

![1673940004704](algorithm.assets/1673940004704.png)

这里这个name，其实是给节点也赋值，虽然前缀树原本是在边上赋值，这里只是多给节点再赋值，也可以不要

然后TreeMap用来存储下一个节点

![1673940123212](algorithm.assets/1673940123212.png)

用有序表的原因是打印的时候想要有顺序的打印，比如按照字典序

![1673940342995](algorithm.assets/1673940342995.png)

深度优先打印

----

### 二叉树递归套路

![1673940479465](algorithm.assets/1673940479465.png)

![1673940549874](algorithm.assets/1673940549874.png)

要求返回2这个节点

利用二叉树的递归套路

![1673940649862](algorithm.assets/1673940649862.png)

左边得到012，右边得到457，然后把3接在中间，返回0和7作为头和尾

![1673940731255](algorithm.assets/1673940731255.png)

![1673940822746](algorithm.assets/1673940822746.png)

----

二叉树递归套路

![1673940859765](algorithm.assets/1673940859765.png)

现在更难一点，返回最大子树的头

![1673941297418](algorithm.assets/1673941297418.png)

![1673941465898](algorithm.assets/1673941465898.png)

需要5个信息，一个是最大搜索二叉树的头节点，一个是它是否是搜索二叉树，一个是左树的最大值，一个是右树的最小值，但是实际上递归行为中不能控制左树右树分别求得最大最小，所以就左树右树把最大最小都求出来，然后还需要最大BST的大小size

![1673941594763](algorithm.assets/1673941594763.png)

![1673942428399](algorithm.assets/1673942428399.png)

![1673943996356](algorithm.assets/1673943996356.png)

把所有可能性都列出来判断

![1673945443269](algorithm.assets/1673945443269.png)

----

### 假设答案法

![1673945643000](algorithm.assets/1673945643000.png)

![1673945829733](algorithm.assets/1673945829733.png)

​	

![1673946724055](algorithm.assets/1673946724055.png)

----

### 压缩数组

![1673947247100](algorithm.assets/1673947247100.png)

![1673947347118](algorithm.assets/1673947347118.png)

尝试法：从0行中找到答案，从0~1行中找到一个答案，不断找到所有的，其中最大的肯定在里面

![1673947470190](algorithm.assets/1673947470190.png)

第0行时，就是上个题的求一个数组的最长连续值的最大累加和，直接用那个方法

第0~1行的时候，我们把两行上下相加，得到-12 12 1 7，然后再用这个方法求出来的就是这两行的最大子矩阵的累加和

下面的也是如此处理

这就是压缩数组的技巧

![1673947721275](algorithm.assets/1673947721275.png)

----

### 贪心

![1673950537672](algorithm.assets/1673950537672.png)

![1673951700225](algorithm.assets/1673951700225.png)

分析从左往右尝试模型，i 位置分情况，如果是X，则不放灯，如果是 . 则分两种情况，i+1是X时，必须放灯，i+1是 . 时，i 就不放灯，让i+1放灯，这就是贪心

![1673952140188](algorithm.assets/1673952140188.png)

![1673952186136](algorithm.assets/1673952186136.png)

----

### 递归

![1673952595611](algorithm.assets/1673952595611.png)

![1673952688342](algorithm.assets/1673952688342.png)

通过先序和中序可以找到在后序数组中的位置和下标，然后递归即可

![1673952924728](algorithm.assets/1673952924728.png)

![1673952947130](algorithm.assets/1673952947130.png)

优化：不一定每次都要遍历去中序数组中找到对应节点，可以建立一个map，开始的时候直接记录中序每一个的位置，就可以直接取出

----



![1673954536761](algorithm.assets/1673954536761.png)

先求深度，直接一直往左走得到

![1673956451170](algorithm.assets/1673956451170.png)

找出深度后，看右树的最左节点是否到最深那层，到了则表示，左树是满的，然后右树递归求就行

如果右树最左节点没到最深层，说明右树肯定是满的，因为最深都到下一层了，然后左树不知道是否满，递归求

![1673956539454](algorithm.assets/1673956539454.png)

![1673956655838](algorithm.assets/1673956655838.png)

这个问号，就是递归这个过程，再找这个子树的右树的最左节点看是否到达底层

![1673956777429](algorithm.assets/1673956777429.png)

![1673956842975](algorithm.assets/1673956842975.png)

![1673957047929](algorithm.assets/1673957047929.png)

----

### 最长递增子序列问题

![1673957130044](algorithm.assets/1673957130044.png)

正常解法：动态规划O(N^2)

下面解法：O(N*logN)

![1673957334546](algorithm.assets/1673957334546.png)

子序列，只能从左往右，所以应该不要3和6，最长是1234

![1673957492446](algorithm.assets/1673957492446.png)

正常dp解法：生成一个dp数组，每个位置记录以arr[i] 结尾的情况下最长子序列的长度，从左往右开始，然后往左边遍历看有几个比他小，然后最后dp[i] 就是解

**优化：**除了有个dp数组外，再开一个ends数组，一开始都是无效值，如果ends[i] 有效，那么表示：所有长度为i+1的递增子序列中，最小的结尾是什么值

![1673957901876](algorithm.assets/1673957901876.png)

刚开始只有一个3，当到arr【1】即2的时候，在ends中二分的找到大于2的最左的位置，就是ends的0位置，然后让2去更新它，然后我们看到ends数组内，连同这个2自己在内，左侧有几个数，只有1个，所以dp【1】=1

![1673958089262](algorithm.assets/1673958089262.png)

到4的时候，此时在ends中二分的找大于4的最左的位置，没有，所以扩充有效区，4加入进去

![1673958150626](algorithm.assets/1673958150626.png)

直到1的时候，大于1最左是0位置的2，更新为1

理解：ends数组的有效区，一定是递增的，因为长度为3的递增子序列的最小结尾不可能大于长度为5的递增子序列的最小结尾

**构建了单调性，就可以把枚举行为省掉**

**优化的入手：1.从数据状况入手  2.从问题本身入手**

----



![1673959245209](algorithm.assets/1673959245209.png)

![1673959464122](algorithm.assets/1673959464122.png)

两种等效，所以可以直接相加

----



![1673959733860](algorithm.assets/1673959733860.png)

![1673962457909](algorithm.assets/1673962457909.png)

直接拿一个变量记录开始遍历数组，然后让每个数交换到自己对应的下标-1的位置，不断循环，可以找到那个没有对应的数字

![1673962662203](algorithm.assets/1673962662203.png)

![1673962723957](algorithm.assets/1673962723957.png)

----

### 递归中人为规定边界

![1673962781780](algorithm.assets/1673962781780.png)

![1673963723212](algorithm.assets/1673963723212.png)

这样递归，根本跑不完

**优化一：平凡解限制条件**

因为两个参数，都是偶数，所以可以找出一个平凡解，所以可以直接限制，如果超过了这个平凡解，那么就不是最优解

**优化二：根据业务进行判断**

因为本题可能出现，先超过固定要解决的那个人气值，然后再通过私聊减人气，从而达到钱最少，但是，肯定不可能到达两倍人气了再进行减少，所以第二个限制条件是两倍的终止条件

![1673965226644](algorithm.assets/1673965226644.png)

![1673965212125](algorithm.assets/1673965212125.png)

litmitCoin是平凡解

![1673965398867](algorithm.assets/1673965398867.png)

![1673968448233](algorithm.assets/1673968448233.png)

改动态规划：

![1673968581528](algorithm.assets/1673968581528.png)

![1673968590313](algorithm.assets/1673968590313.png)

----

### 图的宽度优先遍历

![1674021933066](algorithm.assets/1674021933066.png)

题意就是，在固定的天数中，选择哪条路走到最后，才能获得最大奖励以及最少时长

对每个点，申请一个map，这个map是个有序表，key是从他出发到做完最后一个活动所需要的天数，value是可以赚到的钱

![1674022503918](algorithm.assets/1674022503918.png)

反着的宽度优先遍历，从F点倒推，就可以知道每个点的map存的数据

但是这个A点的map，就会有多个记录，因为有多个路径

![1674022589933](algorithm.assets/1674022589933.png)

从这里面可以看到，10天已经得到1220，比12天得到1040更好，所以直接排除12天这个

做到每个map里面，天数增加，那么收益一定增加的有序表

现在，所有点都完成了map，然后合成一个大表，然后把天数递增，钱没递增的记录删除

这张表可以查询任意一个在某个天数内获得的最大收益

----

### 范围尝试模型

![1674024474047](algorithm.assets/1674024474047.png)

题意理解为，每一个二元运算符，结束的时候，左右两侧都要加上小括号

假设每一个二元运算符，都是最后进行结合的

![1674024676821](algorithm.assets/1674024676821.png)

![1674024756903](algorithm.assets/1674024756903.png)

定义一个函数f，表示用于在L-R这个范围上，得到desire这个结果，那么可以有几种尝试，1位置上的符号作为最后的结合符号，3位置上的，5位置上的....

![1674024868504](algorithm.assets/1674024868504.png)

所以在L-R范围上，假设 i 位置是与运算符号，那么就可以在它的左边和右边分别调用得到结果

![1674024986493](algorithm.assets/1674024986493.png)

这个函数是用于检查字符串的有效性的，因为0，2，4这些位置上，必须是0或者1，而1，3，5这些位置上必须是运算符号

![1674025028766](algorithm.assets/1674025028766.png)

![1674025139208](algorithm.assets/1674025139208.png)

上面检验有效性的时候保证了符号都在1，3，5区域，这样就L和R不会压中逻辑符号

第一个basecase，表示LR只能是0或者1

L-R范围上，不止一个字符的情况下，只能是3，5，7...个字符，不能是偶数，因为边界不能是符号

![1674025478004](algorithm.assets/1674025478004.png)

![1674025504364](algorithm.assets/1674025504364.png)

改dp，三个参数，有个参数是desire，要么true要么false，所以两张表就行

![1674025593987](algorithm.assets/1674025593987.png)

因为L不可能大于R，所以两张表的左下半区废掉

因为L和R不可能压中符号，所以L和R都不可能等于1，3，5...

![1674025754158](algorithm.assets/1674025754158.png)

对角线搞定后，从左到右，从下往上

行号从N-3开始填，因为最后一行只有对角线，已经填好，然后上一行是废掉的，所以N-3开始，每次-2

col从左到右，所以直接等一row+2，+2是因为下一个是不需要填的

![1674026002198](algorithm.assets/1674026002198.png)

剩下直接抄递归

![1674026019014](algorithm.assets/1674026019014.png)

为什么从下往上，应该是因为，最后一行已经确定完了，倒数第二行也是不用填的，所以可以从下往上，如果从上往下不知道从哪里开始

----



![1674027434298](algorithm.assets/1674027434298.png)

**看到子串和子数组的问题，就想以每个位置结尾的情况下怎么样**

以 i 位置结尾的情况下，往前面推

第一个瓶颈，肯定到达不了上一个相同字符的位置，比如 i 是a，i-k位置也是a，那么肯定到不了i-k

第二个瓶颈，i位置往前推的长度肯定超越不了 i-1 位置往前推的长度

![1674028992957](algorithm.assets/1674028992957.png)

![1674029177610](algorithm.assets/1674029177610.png)

map用于记录字符上次出现的位置

pre是 i-1 推出的位置

----

### 编辑距离问题

![1674029352946](algorithm.assets/1674029352946.png)

![1674029587922](algorithm.assets/1674029587922.png)

i 和 j 不是位置，str1【i】str1前缀长度为 i 的字符串，编辑成str2【j】前缀长度为 j 的字符串的最低代价

dp【i】【j】就是表示str1【0...i-1】编辑成str2【0...j-1】的最低代价

而dp【0】【0】就是表示空串，前缀为0

第一行，从空串变换为s，sk，skb，都是用的插入代价，变成s为*代价，sk就是两个插入代价2 *

第一列则是，从a，ab，abc，变成空串的代价，就是删除的代价

![1674029841312](algorithm.assets/1674029841312.png)

现在求普遍位置，

![1674030079316](algorithm.assets/1674030079316.png)

第一种可能性，a1bck的前面，a1bc，变成abc，然后删除k，代价就是dp【i-1】【j】+del

第二种可能性，abcd变成abcde的前面部分的abcd，然后再加上e，代价是dp【i】【j-1】+add

第三种可能性，abcds变成abcdt，先把abcd变成abcd，然后再把s变成t，代价是dp【i-1】【j-1】+replace

第四种可能性，两个字符串的结尾字符相同，就只需要把前面的变成相同的就行，代价dp【i-1】【j-1】

每一个格子，根自己上一个，左一个，左上角有关，所以接下来的都是从左往右，从上往下开始推断

![1674030826399](algorithm.assets/1674030826399.png)

----

### 贪心：删除字符使字典序最小

![1674031005553](algorithm.assets/1674031005553.png)

先遍历一遍，得到每个字符的词频表

然后每来到一个字符，检查一下，看是否还有相同的在后面，有的话就词频-1

![1674031155048](algorithm.assets/1674031155048.png)

然后当来到6位置的时候，后续没有a了，划定一个范围：如果我只留一个字符，剩下东西都删掉，能够保证不会有某种字符缺少的范围就是此时的范围

![1674031362056](algorithm.assets/1674031362056.png)

此时我们选择保留ASCII码最小的且是最左的a，是1号位置，那么起始位置就是1号位置，前面0号位置不要，然后把后面其他的a删掉，再重复过程，此时还剩下，bcbbct，继续建立词频表，然后继续得到找到范围后，保留ascii码最小的和最左的，删掉其他的

![1674031856524](algorithm.assets/1674031856524.png)

这个代码应该把else中的代码提出来放到if前面，因为有可能直接就遇到只有1个词频的字符，然后直接--的时候，minASCIndex还在上一个位置

时间复杂度：每次挑选都只挑一个字符，假设K种字符，每次挑选都会遍历一遍，所以O(K*N)

----



![1674032993878](algorithm.assets/1674032993878.png)

先根据长度组织，然后根据字典序组织，要保证是子序列，这样的情况下，给出一个子序列，需要返回它的编号

![1674033115300](algorithm.assets/1674033115300.png)

给出一个函数 f(N)，表示长度为N的子序列有多少个，还要一个g(char，len)，表示以char字符开头，长度为len的子序列有多少个

![1674034490697](algorithm.assets/1674034490697.png)

![1674034509940](algorithm.assets/1674034509940.png)

求a开头总长度为7的子序列有多少个，就是求b开头，c开头....总长度为6的子序列多少个，累加就行

![1674034643325](algorithm.assets/1674034643325.png)

不规定开头，就是从a-z直接全部累加

现在看普遍情况，问djv是第几号，不管其他，肯定排在长度为1和长度为2的后面，因为它长度为3

所以先算所有长度为1，长度为2的子序列的数量，加起来

然后我们看到，是d开头，所以a，b，c开头，长度为3的，都在它前面

然后看到第二个字符是 j ，所以e，f，g...到 i ，长度为2的都被压在前面

![1674035011828](algorithm.assets/1674035011828.png)

然后dj已经确定了，所以从k-u，长度为1的子序列数量也在前面

![1674034824808](algorithm.assets/1674034824808.png)

----

## 高级班实战题

----

### 舍去可能性技巧

![1674042373982](algorithm.assets/1674042373982.png)

非基于比较的排序，往往是数据状况在一个可控范围内

而如果用基于比较的排序，最快的也只能是快排、堆排、归并，但是时间复杂度都是O(N*logN)

首先我们准备一些容器，比如9个数，那么就准备10个容器，然后遍历一遍数组，得到最大值和最小值，此时我们可以让在最大值和最小值之间的值等分到容器之中

然后再遍历一遍数组，把每个数放到对应容器之中

因为我们准备的桶比数更多一个，所以左右两端一定分别有最大和最小值，同时，中间一定有空桶

那么我们可以知道，空桶的左边的最大值和空桶右边的最小值肯定是相邻的，同时，他们的差值，一定是大于这个桶所能包含的范围的，再看到桶内，桶内之间的相邻两数的差距，肯定是小于桶的范围的，所以，题目就直接转化为了，相邻桶之间相邻数的差值，求最大值

因此，流程可以更加优化为，每个桶内，只需要保留进这个桶的数中的最大值和最小值

实际上，就可以直接开一个数组，一个数组表示最大值数组，一个是最小值

![1674047498827](algorithm.assets/1674047498827.png)

![1674047632253](algorithm.assets/1674047632253.png)

![1674050355306](algorithm.assets/1674050355306.png)

我们看到，这种情况下，起视空桶两边的结果并不一定是最大的

设置空桶是为了设置一个平凡解，给流程带来优化

----

### 假设答案分析答案性质

![1674050703738](algorithm.assets/1674050703738.png)

每个区间内数字的异或和都为0

![1674050986270](algorithm.assets/1674050986270.png)

返回最多能有多少个区间内的异或和是0

异或就是无进位相加

我们设置一个dp数组，不断从0开始尝试，0~1，0~2上，最优划分下有几个子数组异或和为0，所以dp【i】的意义就是，arr【0~i】上最优划分能有最多几个子数组异或和为0

普遍位置上：

第一种可能：第0~i 部分上，最后的部分，异或和不为0，所以dp【i】=dp【i-1】

第二种可能：第0~i 部分上，最后的部分，异或和为0

![1674053121683](algorithm.assets/1674053121683.png)

当我们看到，最后一部分是异或和为0的情况，那么假设是k-i这个范围异或和为0，那么可以得到一个性质，k是距离 i 最近的那个能让k-i 异或和为0的

因为如果k-i 之间有一个L能让L-i 可以异或和为0，那么这样就不是最优划分了

接下来我们就是要找到这个k

![1674054478317](algorithm.assets/1674054478317.png)

假设0-i 异或和是1000，想找k，那么只需要找到 i 之前，哪一个数的前缀和的异或和是1000就是了

用一个map，来存0~0范围上的前缀异或和，0~1，0~2的前缀异或和，value是他最近出现的位置，key是前缀和的异或和

比如0~17的异或和是1000，0~i 的异或和是1000，那么说明18~i 的异或和就是0

![1674055737218](algorithm.assets/1674055737218.png)

![1674057567974](algorithm.assets/1674057567974.png)

刚开始，空的时候，异或和是0，位置-1，然后3来了，就是3，然后3和2异或为1，开始判断，前面没有出现过1，所以dp【1】=dp【0】

![1674057786393](algorithm.assets/1674057786393.png)

然后到2位置，321异或为0，此时查到-1位置为0，所以说明从-1的下一个位置0开始，0~2的异或和为0，此时比较两种情况，第一种直接取前面的0，第二种是这一部分为1个，然后拼上前面的0，取最大，所以为1，然后map里的前缀和为0的位置，要更新为最近的2位置

![1674058148843](algorithm.assets/1674058148843.png)

到4号位置时，0和4异或还是4，说明了4~4位置异或和为0，所以产生了第二种可能，最后的异或和为0，然后拼上0~3部分的数量，总共为2，然后第一种可能的情况下是直接取前面的值1，pk后取最大值2

周而复始求出最后的值

![1674058406593](algorithm.assets/1674058406593.png)

----

### 背包，斜率优化

![1674215200489](algorithm.assets/1674215200489.png)

![1674215329154](algorithm.assets/1674215329154.png)

大流程就是，不断枚举尝试，左边取任意枚的数组，拼0块钱有a种方式，右边取一枚的，拼10块钱，有b种方式，那么总方式就是a*b

然后不断枚举，左边1，右边9....直到左边拼10块钱有z种，右边0块钱Y种，得到z*y，然后全部累加

![1674216147722](algorithm.assets/1674216147722.png)

dp【i】【j】就是arr【0-i】上，组成 j 块钱的方法数，第一列组成0块钱，都是1种方法，就是什么都不要

注意，这个数组是任意取的数组

第一行因为是arr【0-0】只有一个3，所以3的整数倍都可以直接取得，方法数为1，其他都为0

其他普遍位置，有几种可能

第一种，i 位置上一张也不取，就直接满足，dp【i】【j】=dp【i-1】【j】

第二种可能，i 位置上取了一张，那么说明，前面0-i-1上要满足 j-arr[ i ] 的钱，所以dp【i】【j】=dp【i-1】【j-arr【i】】

接下来的可能就是，i 位置上取了2张，3张....

![1674216503653](algorithm.assets/1674216503653.png)

![1674216720644](algorithm.assets/1674216720644.png)

分析，如果要求第二行的8位置，那么第一种可能是取0张2，那么就变成3块钱满足8，就是上方的0种方法，然后第二种可能是取1张2，然后就变成3块钱满足6，发现有一种方法，就累加上去，然后不断增加取2的张数，直到越界

所以我们可以发现，都是取得上一行得值，然后不断往左边跳转，当前这个 i 位置得值是多少，就跳几步

但是我们这种跳转是不断得枚举行为，实际上我们可以发现，前面得位置已经枚举过了，只需要通过观察可以发现，当前格子上方值加上左边跳转位置得值即可

![1674216963570](algorithm.assets/1674216963570.png)

然后直到求出最后一行得值

然后第二张表，没有枚举行为，因为直接就是选择要或者不要，不能多取，生成两张表后，两张表得最后一行去拼答案

----

### 上中位数二分求解

![1674217108124](algorithm.assets/1674217108124.png)

![1674217489576](algorithm.assets/1674217489576.png)

假设这题是求最小得k个数字，此时k=6，那么我们就找第6小得数

首先在A中二分得到中点位置，发现他左边压过了2个数，然后用这个5，去B里二分，发现比2和4打，此时发现5只压过了4个数，他是第5小的，不够，要找更大一点的，所以在A的右边二分找，先找到7，在A中压过3个数，b中也压过3个数，他是第七小的，所以A中不行，已经比第六大了

所以我们同样流程去B数组中走一遍，发现6在B压过2个数，在A中压过3个数，就是第六小的，所以找到了

时间复杂度就是O(logN*logM)

**最优解：**

上中位数：偶数个数的求中位数会有两个，前面那个就是上中位数

两个有序数组，长度相同情况下，先分别二分求中点，然后比较值，相同的话，他们的值一定是上中位数

![1674218096939](algorithm.assets/1674218096939.png)

如果不相等，直接递归求A左边和B右边的，整体的上中位数，就是整个A和B的上中位数

![1674218352080](algorithm.assets/1674218352080.png)

只要子过程的数量相同，就可以重复求上中位数

如果是奇数长度数组，同样，如果中点相同，那么一定是第五小的值，就是上中位数，这里的数字只代表下标

![1674218500386](algorithm.assets/1674218500386.png)

![1674218567812](algorithm.assets/1674218567812.png)

推断得知，B的345可能是第五小的数，这时不能递归，因为长度不一样，所以直接手动验证一下3’，如果3‘ 大于2，那么就说明3‘ 就是第五小的数，如果不是，就排除了3’，把后面4‘和5’ 与 1，2 进行递归

现在我们就有个原型函数，可以解出等长的两段数组的中位数

![1674445918199](algorithm.assets/1674445918199.png)

举例子，假设A长度10，B长度17，那么如果 k 的取值范围是1-短数组长度，那么就可以直接开始调用函数，假设

k = 6，那么直接取1-6和1‘-6’ 进行调函数求上中位数，得到结果就是整体的上中位数，也就是第k小

第二种情况，如果 长数组长度< k < 两数组长度之和（17<k<=27），

![1674446175370](algorithm.assets/1674446175370.png)

这种情况下，1-5不可能，因为就算比17‘ 大，也不够23，同理B数组中是13’开始才有可能

但是这时不能直接调用那个函数，因为此时两个数组都只有5个数，求出来上中位数是第五小的，加上前面淘汰的17个数，得到的答案是第22小的

此时我们应该直接手动比较6和13‘是否为第23小，如果6大于等于17’，那么直接得出答案，否则淘汰，如果13‘大于等于10也是得出答案，否则淘汰，如果此时两个都淘汰了，就淘汰了19个数了，剩下8个数求第四小，加起来正好是第23小

剩下一种情况是，10<k<=17，假设k=15

![1674446658226](algorithm.assets/1674446658226.png)

此时淘汰掉一些后，上下两个数组不相同，开始手动淘汰5’，然后发现，两个数组求出来的第10小，加上前面淘汰的5个，正好是第15小

![1674446762969](algorithm.assets/1674446762969.png)

![1674446775739](algorithm.assets/1674446775739.png)

分三种可能性进行调用函数原型

![1674446836757](algorithm.assets/1674446836757.png)

时间复杂度：要么手动验证O(1),要么二分区域，所以是O(log min{N,M})，N和M是数组长度，因为二分区域不可能大于数组长度

----

### 约瑟夫环问题

![1674447023663](algorithm.assets/1674447023663.png)

环形单链表，给出一个头节点，然后给个参数m，从头节点开始报数，报到m的节点就被淘汰，然后从下一个节点重新开始报数，直到最后只剩一个节点

普通暴力解法：O(m*N)

优化解：O(N)，通过一个公式，倒推出在某一个长度时，活下来的那个人的编号

最初时，只剩一个人，长度为1，编号为1，我们想通过这个信息，倒推长度为2时，活下来的人的编号，这个函数应该只跟上一级的长度，现在状态的编号，以及常数m有关

![1674451316963](algorithm.assets/1674451316963.png)

这是y=x%i 的图像

![1674451625405](algorithm.assets/1674451625405.png)

如果我们不淘汰，那么可以得到报数和编号的图像

![1674451725662](algorithm.assets/1674451725662.png)

两个图像可以通过左加右减，上加下减来得到

现在开始推，新旧节点之间的位置关系

![1674451974028](algorithm.assets/1674451974028.png)

我们做延长线，发现在-2位置与y=1相交，而原来那个号和报数的图像中，也是与y=1相交，所以可以发现，那个图像往左平移3个单位得到现在这个图像

![1674452063915](algorithm.assets/1674452063915.png)

![1674452078564](algorithm.assets/1674452078564.png)

S是被杀节点的编号，而我们通过之前那个公式，被杀号=(报数位置-1)%i + 1可以得到，S=(m-1)% i + 1

所以最终化简得到：老 = (新 + m - 1)% i + 1

![1674452407500](algorithm.assets/1674452407500.png)

![1674452487660](algorithm.assets/1674452487660.png)

![1674452518940](algorithm.assets/1674452518940.png)

而这一题，说的是给出几个数字，然后有一些人，每次到一个人，就取一个数字，数字是循环取用的，比如0号人取了7这个数字，那么就代表从这人开始第七个人淘汰，其实就是每次m会变

![1674454576029](algorithm.assets/1674454576029.png)

----

### 有序表解决大楼轮廓问题

![1674454767353](algorithm.assets/1674454767353.png)

SB树比赛最常用

他们的时间复杂度都相同，只是用不同原理实现相同功能，有序表的所有**增删改查都是O(logN)**

**Java中有序表叫TreeMap**

![1674454910797](algorithm.assets/1674454910797.png)

如果Key是自己定义的类型，就必须写比较器

![1674455088614](algorithm.assets/1674455088614.png)

![1674455217413](algorithm.assets/1674455217413.png)

给出多组数据代表大楼，然后求大楼轮廓线

**难点：如何用技术语言描述轮廓的变化**

实际就是描述最高高度的变化

![1674455809019](algorithm.assets/1674455809019.png)

每次高度变化了，就知道前面一个高度的终点在哪里了

![1674456715057](algorithm.assets/1674456715057.png)

这样一个大楼，我们把大楼对象改变一下，变成[2，add，8]表示2的位置增加了一个8高度，然后6的位置减小了一个8的高度，其他也是这样

然后我们对这些对象进行排序，根据一位数据进行排序，如果相同就是 add 排在 del 前面，如果还相同就无所谓

![1674456954066](algorithm.assets/1674456954066.png)

然后我们准备一个表map1，key是这个高度，然后value是出现的次数

map2，key是坐标，value是当前的最大高度

![1674457221461](algorithm.assets/1674457221461.png)

![1674457282372](algorithm.assets/1674457282372.png)

当8这个高度在map1中已经被删完了，那么此时map1中的最大高度是5，所以加入map2的数据是6，5

![1674457454628](algorithm.assets/1674457454628.png)

这里看得到，5的词频变2，然后2位置最大高度还是5

![1674457520913](algorithm.assets/1674457520913.png)

最后减完，10，0

同一个位置多次加减，以最后一次为准

![1674457581150](algorithm.assets/1674457581150.png)

![1674458267363](algorithm.assets/1674458267363.png)

![1674458507953](algorithm.assets/1674458507953.png)

为什么加要放在减前面：

![1674458592389](algorithm.assets/1674458592389.png)

![1674458833356](algorithm.assets/1674458833356.png)

![1674458925018](algorithm.assets/1674458925018.png)

----

### 滑动窗口

![1674458996208](algorithm.assets/1674458996208.png)

**看到正数数组，构建单调性**

两个指针，滑动窗口

![1674459117675](algorithm.assets/1674459117675.png)

正数数组，范围和累加的单调性，只会增加，所以双指针进行滑动窗口

![1674459494675](algorithm.assets/1674459494675.png)

----

增加难度：如果数组中有0，有负数，该怎么找到累加和为k的最长子数组长度

利用一个哈希表，记录之前的前缀和以及该前缀和最早出现的位置，从这个位置开始，下一个位置到 i 位置的累加和就是要求的长度了

----

### 缩减可能性技巧

人为分析一些可能性，排除掉不可能的

![1674459670643](algorithm.assets/1674459670643.png)

子数组问题三：无序数组，有0有负数，找到累加和小于等于k的最长子数组的长度

![1674460146966](algorithm.assets/1674460146966.png)

两个数组，分别表示从 i 出发的子数组中，最小的累加和的值

最小的累加和时，右边界的位置

![1674460295965](algorithm.assets/1674460295965.png)

从右往左开始看，其实也印证了子数组子串问题，考虑以 i 结尾，这只是反向推导

![1674460386138](algorithm.assets/1674460386138.png)

注意minSum数组的含义是从 i 位置出发所有子数组能得到的最小累加和

**最优解：O(N)**

![1674460770981](algorithm.assets/1674460770981.png)

假设从0位置开始，边界为 i ，然后最小累加和是a，如果a<=k，那么我们就可以从i+1位置继续看，如果a+b<=k，那么看 j+1位置开始，如果此时a+b+c>k，那么我们可以知道，最长就是0-j 了，因为 j+1位置开始最小累加和加上前面的a+b，都要比k大

所以这个问题变成了，从0开始有一块，后面都是一块块的

![1674460955041](algorithm.assets/1674460955041.png)

直到发现有一块加上后>k，那么就知道了我们的边界了

但是这个题是找的子数组中长度最长的，累加和<=k的，从0开始可能能找到一个答案，但是不一定是最好的，从1开始同样也可能找到一个答案，但是如果每次都从0开始，然后再从1开始，这样复杂度就是O(N^2)

![1674461291909](algorithm.assets/1674461291909.png)

事实上应该，从1这边开始时，维持这个窗口不变，直接看18号位置开始能否加进来这一块，此时的Sum=Sum-arr[0]

因为有可能，从1开始的边界在17内，这种可能性没用，直接舍去，直接扩展到18号位置，看能否加入进来

**只关心能否让答案变得更长，不严格纠结每个开头情况下的答案，这样的可能性舍弃**

![1674461807478](algorithm.assets/1674461807478.png)

![1674461830312](algorithm.assets/1674461830312.png)

----



![1674461959349](algorithm.assets/1674461959349.png)

就是谁把最后一个铜板拿完谁赢

直接把数组中所有数异或起来，得到的结果如果不是0，那么先手赢，如果是0，那么后手赢

那么也可以转化为，如何让先手拿了之后的数组异或和为0，但是这样的前提是，一开始的异或和不能为0

----

### 伪进制

![1674530627101](algorithm.assets/1674530627101.png)

![1674530848147](algorithm.assets/1674530848147.png)

这里是一个新的进制，不是26进制，比如我们是3进制的时候，9可以用100来表达，但是如果是3伪进制，那么每个位上都是1-3，不能是0，那么就只能表达为23

![1674531006052](algorithm.assets/1674531006052.png)

92-49=43，用不到7^3这个高位了，直接去掉

![1674531152858](algorithm.assets/1674531152858.png)

![1674531237624](algorithm.assets/1674531237624.png)

![1674531282856](algorithm.assets/1674531282856.png)

![1674531290991](algorithm.assets/1674531290991.png)

![1674531382830](algorithm.assets/1674531382830.png)

----

### 尝试的能力

![1674531560820](algorithm.assets/1674531560820.png)

![1674531832962](algorithm.assets/1674531832962.png)

no就是不使用能力取相反数，yes就是使用了能力

主函数

![1674533091721](algorithm.assets/1674533091721.png)

把每一个格子都取得对应值，然后遍历得到最大值

basecase：当在最左列时，说明刚登陆，要么用能力，要么不用能力

如果不是在最左列，那么到当前位置可能是从左上，左，左下过来的

那么分别把3种情况都列出来，得到preNo是之前一次都没用能力的最大路径和，preYes是之前用了一次的最大路径和

然后现在求当前位置，也是三种， 要么一次也不用，要么之前没用，现在这个位置用，要么之前用了，现在不用

![1674535703355](algorithm.assets/1674535703355.png)

![1674535717481](algorithm.assets/1674535717481.png)

**暴力递归最简单改动态规划：记忆化搜索**

先准备一个缓存表，判定大小，然后让下面过程带着这个数组走

如果这个位置的dp表不为空则直接返回了，否则暴力递归求解

既然有缓存，肯定有加入缓存的时候，就是在每一个条件的return之前，先把缓存加入进去

![1674536006080](algorithm.assets/1674536006080.png)

![1674536030339](algorithm.assets/1674536030339.png)

![1674536060363](algorithm.assets/1674536060363.png)

这种缓存法，让每个格子只用算一次了，复杂度优化到O(M*N)

**这题每个格子只依赖3个位置，没有枚举行为，所以记忆化搜索的复杂度可以认为跟经典动态规划相同，但是如果存在枚举行为，那么改成严格表结构的动态规划就有意义了**

----



![1674536485898](algorithm.assets/1674536485898.png)

用栈做很麻烦，这里用递归做

一个函数，传入这个字符串，还有一个 i 

返回的第一个值a：就是从 i 开始往后走，要么遇到右括号，要么到字符串结尾才停止，然后返回的是计算的结果

返回的第二个值b：返回的是结尾的位置下标，比如遇到了右括号就停止了，那么b就是右括号的位置

![1674536824071](algorithm.assets/1674536824071.png)

如果是没有括号的情况下，用栈做：

![1674536976748](algorithm.assets/1674536976748.png)

遇到符号就把数字和符号加进去，但是要先看栈顶是否是乘除符号，如果是，则先弹出两个，计算完再加入进去，比如这里就先算64*9后，再把数字和+号放进去

**如果有括号串，那么用递归结构**

![1674537329851](algorithm.assets/1674537329851.png)

其实递归过程里，也是用栈来做，但是遇到了括号的时候，那么就不关心这个括号，直接跳过到下一个，开始子过程的递归

![1674537484867](algorithm.assets/1674537484867.png)

直到 f(8)的时候，遇到右括号，返回计算结果，同时返回结尾位置，所以 f(3)的位置，就直接从12号位置开始

![1674537620952](algorithm.assets/1674537620952.png)

![1674537648680](algorithm.assets/1674537648680.png)

这里的返回值是一个数组，只取第一个值，就是那个a

这里面，你可以用栈，也可以用队列，这里java里面这个是双端链表

![1674538458174](algorithm.assets/1674538458174.png)

![1674538535862](algorithm.assets/1674538535862.png)

getNum是最后只剩下加减了的计算

----

### 动态规划空间压缩技巧

![1674538638432](algorithm.assets/1674538638432.png)

![1674538803616](algorithm.assets/1674538803616.png)

dp【i】【j】指的是，str1必须以 i 结尾，str2必须以 j 结尾，同时最长公共子串必须以 i 和 j 结尾的情况下，最长公共子串的长度

矩阵的第一行和第一列，都是1或者0，因为如果要以 i 和 j 结尾的公共子串，那么必须相等，不相等肯定不是公共子串

![1674539247725](algorithm.assets/1674539247725.png)

因此整个表很多位置都是0，那么普遍位置我们来看，i 和 j 相等的情况下，那么整个字符串长度就依赖于前面的长度，那就是i-1和 j-1了，就是依赖左上角位置，所以直接左上角位置+1就行

![1674539550555](algorithm.assets/1674539550555.png)

开始空间压缩：从最右上角开始，以斜线方式，用几个变量即可得到整条斜线的答案

![1674539663838](algorithm.assets/1674539663838.png)

row和col 控制起始点的位置，如果col不等于0就--，就是起始点一开始都在第一行，然后到0后，row开始++，起始点转换到第一列，大while里面 i 和 j 取得起始点位置后开始斜线计算

![1674539885010](algorithm.assets/1674539885010.png)

这也不是最优解，最优解是用后缀数组

----



![1674540135250](algorithm.assets/1674540135250.png)

![1674540995475](algorithm.assets/1674540995475.png)

这题是子序列问题，所以没有规定必须要以谁结尾，所以求得是最右下角，整个两个字符串内得最长子序列得长度

要先列出可能性：以结尾是谁来分可能性

第一种，不以 i ，也不以 j 结尾

第二种，以 i ，不以 j 

第三种，不以 i，以 j

第四种，以 i，以 j，隐含str1[i] = str2[j]

![1674541268009](algorithm.assets/1674541268009.png)

四种求max

----

### 排序+双指针解决坐船过河问题

![1674541430043](algorithm.assets/1674541430043.png)

![1674541648585](algorithm.assets/1674541648585.png)

先做一个排序，排序完后，先求一个limit/2，找到<=5最右位置，如果是-1，那就表示没人能两人一起坐船，都只能一人一艘船

![1674541740563](algorithm.assets/1674541740563.png)

还有可能<=5最右位置越界，那么就表明任意两个人都可以一起坐船，所以直接N/2

![1674541818807](algorithm.assets/1674541818807.png)

然后开始使用双指针，L和R分别在分界线得左右边，然后比较相加值是否大于limit，如果大于，说明L对应位置加上右边任何都不行，所以L左移

![1674541912473](algorithm.assets/1674541912473.png)

直到3得时候发现可以了，然后R再尝试往右边移动，直到越界，此时发现这个3，可以跟右边2个7对应上船，那么我们直接可以直到，3自己和他左边得一个数，可以去把右边得两个7给对应了

![1674542143013](algorithm.assets/1674542143013.png)

指针移完后，右边多了一个9，单独一条船，左边4和5，都是可以两两结合得

![1674542315466](algorithm.assets/1674542315466.png)

b/2要向上取整

![1674542417847](algorithm.assets/1674542417847.png)

向上取整，可以长度+1再/2

![1674542598427](algorithm.assets/1674542598427.png)

左侧有L+1个数，求出X号得个数就直到对号得个数了

![1674542830763](algorithm.assets/1674542830763.png)

如果solved≠0，那么L这边就要看能滑过去几个了，如果右侧太多了左侧不够就会得到L=-1

----

### 范围尝试模型

![1674543288784](algorithm.assets/1674543288784.png)

**可用解法：字符串跟他得逆序串，求其最长公共子序列，就是原始字符串得最长回文子序列**

![1674543629765](algorithm.assets/1674543629765.png)

dp【i】【j】表示str【i...j】上最长回文子序列多长，要是这个表填好，那么最右上角就是我们要得从0-10范围上最长回文子序列

**既然是范围上尝试模型，i肯定>j，因为没有-1-0范围上，所以表格左下半部分没用**

对角线上，i = j 所以肯定都是长度为1

然后看倒数第二条对角线，开始是从0-1范围上，此时直接看0位置和1位置是否相等，相等为2，不相等为1，整个倒数第二条对角线都是这样，因为都是两个数

![1674543976333](algorithm.assets/1674543976333.png)

**范围上尝试得模型，一定要重点讨论开头和结尾，可能性直接就是以开头怎么样，结尾怎么样来讨论得**

第一种可能，形成的最长回文子序列，不以 i 开头，不以 j 结尾

第二种，以 i 开头，不以 j 结尾

第三种，不以 i ，以 j 结尾

第四种，以 i ，以 j 

![1674544250605](algorithm.assets/1674544250605.png)

i [  ] j  这个字符串来看，不以i结尾，不以 j 结尾，那么就是dp【 i + 1 】【j-1】

所以我们可以看到，普遍位置是依赖左边，左下和下方，所以是从下往上，从左往右填

----

还是范围上尝试模型

![1674544433512](algorithm.assets/1674544433512.png)

求 str【i....j】范围上，至少添几个才能变成回文串

![1674544626561](algorithm.assets/1674544626561.png)

对角线只有一个数字，所以不需要添加，倒数第二个对角线，两个数字，相同就不添加，这个例子都不相同，所以都是1

还是讨论普遍位置：讨论开头和结尾位置

第一种情况，先把 i+1-j 位置上需要添加几个字符求出，然后把 i 位置在最后添加一个，dp[i+1] [j] + 1

第二种，最后搞定 j 这个位置，所以先搞定 i - j-1位置，dp [i] [j-1] + 1

第三种，i 位置字符 = j 位置字符，dp [i+1] [j-1]

![1674545475075](algorithm.assets/1674545475075.png)

表格填好后，我们知道最终答案是3，总共8个字符，需要添加3个，所以最后是11个字符，那么我们再看，这个3是根据下方的答案得到的，下方就是dp【i+1】【j】，说明了我们的0-7的答案是从1-7的答案得到后，再把0字符拷贝一个到最后得到的，所以0位置和10位置都要填a

接下来继续倒推，1-7范围上的2是怎么得到的

![1674545737342](algorithm.assets/1674545737342.png)

1位置和7位置相同，所以直接看2-6位置上的答案，1位置和7位置直接保留，他们在最外面，2和6相同

如果用户要求还原一种路径，整张表就可以这样去还原所有路径

**范围上尝试模型，是以 i 点开头，j 点结尾的情况下，看可能性整理能否解决问题，如果不能则需要更换尝试模型**

----

### 从左往右+范围尝试模型

![1674546036190](algorithm.assets/1674546036190.png)

可能性是以 i 开头来讨论的，假设递归过程是 i 往后所有字符串，最少能够切成几个回文部分，主函数调用f(0)

![1674546424008](algorithm.assets/1674546424008.png)

开始时，a是回文串，调用f(1)

然后看第二种，aa是回文串，调用f(2)

第三种，aab不是回文串，排除，一直尝试下去，最后来看，比如第一种就是f(1)的结果+1，比较所有结果最小的就是

就是尝试从左往右的第一块回文字符串，都有哪些字符

![1674548228350](algorithm.assets/1674548228350.png)

我们发现，可变参数永远在变大，i 位置依赖的是后面的位置，所以从右往左填，最左就是答案，复杂度是O(N^3)

每一次枚举，要经理一个O(N)的验证回文，然后递归调用最坏情况是O(N^2)

如何省时间，可以把验证回文改成O(1)

就是再加个表做预处理

![1674548590186](algorithm.assets/1674548590186.png)

这张表dp【i】【j】就是看i-j是否是回文

每一个普遍格子只依赖左下角值，因为如果i≠j，那么不可能是回文

![1674548653486](algorithm.assets/1674548653486.png)

![1674548707557](algorithm.assets/1674548707557.png)

![1674548765021](algorithm.assets/1674548765021.png)

----

还是范围上尝试模型

![1674548853559](algorithm.assets/1674548853559.png)

dp【i】【j】表示 i -j 有多少种保留方案是回文串(移除方案就是看保留哪些)

可能性整理：

![1674549219102](algorithm.assets/1674549219102.png)

这个dp【i】【j-1】实际上是2和4的两种可能性，因为这个首先肯定不包含j，但是这也不一定包含i，因为我们定义的是dp【i】【j】含义为 i-j 范围上有多少种保留方案，没说一定要以 i 开头，以 j 结尾，可能以i开头，也可能不以 i 开头

![1674549638863](algorithm.assets/1674549638863.png)

可以看到这个例子，dp【0】【1】的解，0-1范围上有两种保留方案，分别是可能性3和可能性4，这里面其实就是代表了dp【i】【j-1】

就是说，i-j-1范围上所有的可能性，这个所有就包含了以 i 开头和不以 i 开头

![1674549860422](algorithm.assets/1674549860422.png)

这里面我们看到，会多算一个第三种可能性，所以要减去dp【i+1】【j-1】

那么现在还差第一种情况，如果 i 位置和 j 位置不相同，那么就没有回文串，就没有第一种情况

如果相同，那么又分为：

第一种，只保留 i 位置和 j 位置的回文串

第二种，不管 i+1-j-1 位置上能有多少种可能，在两边加上 i 和 j ，答案是dp【i+1】【j-1】+1

![1674550093454](algorithm.assets/1674550093454.png)

----

### BFPRT

![1674562578939](algorithm.assets/1674562578939.png)

如果只是笔试题，可以直接用荷兰国旗问题，也就是快排来做，先在数组随机找一个数，然后将数组分为三部分，中间是等于这个数的，然后左右分别是小于和大于的，如果中间命中则可以返回，否则左右两边只走一边去递归，可以证明整体时间复杂度是O(N)

这里给出一个大名鼎鼎的算法：BFPRT

这个算法，后面步骤都和上面方法一样，但是不同点就在于，第一步选择这个数，不是随机的了，这个选择法可以得到不是用概率的O(N)，而是严格的O(N)

整个方法是 f 函数，目的是arr中求第 k 小的数

第一步，每5个数分一组

第二步，每一组求中位数，放到数组marr中，这个过程O(N)

第三步，求marr的中位数，这个过程是递归调用 f 函数，f(marr，marr.length / 2 )，这样的参数调用，求得就是marr得上中位数

返回值如果是 x ，那么这个x就是我们原步骤得第一步得 x

接下来我们证明为什么是O(N)：

原方法得x，我们无法估计左右两边得规模，那么我们想要估计<x的最多有多少个，这个不好估计，我们可以估计，>x的最少有多少个，然后用N减去就可以知道了

![1674565005006](algorithm.assets/1674565005006.png)

假设这5个组都排好序从小到大，取出来的中位数组成marr，那么再求marr的中位数是c，那么在marr中至少有N/10个数比c大，我们又可以看到，d和e也是各组的中位数，所以也能得到他们在各组内分别有N/10个数比它大，所以至少总共3N/10个数比c大，所以左边规模固定了是最多7N/10比c大

![1674565300849](algorithm.assets/1674565300849.png)

![1674565528661](algorithm.assets/1674565528661.png)

![1674565514994](algorithm.assets/1674565514994.png)

![1674565619916](algorithm.assets/1674565619916.png)

----

### 斜率优化

![1674565723025](algorithm.assets/1674565723025.png)

![1674623933539](algorithm.assets/1674623933539.png)

裂开的部分是递增的，不能先分成2，再分成1，必须增大

![1674624456623](algorithm.assets/1674624456623.png)

当我们画出表，初始basecase填好后，发现要求的是1，7这个点，那么他能裂开成1，6和2，5....

就是表上打勾的地方是他依赖的，累加起来就是这个星号的值

因为依赖左下角，所以我们逆序来填，从下往上，从左往右

![1674624759257](algorithm.assets/1674624759257.png)

这个就是暴力递归到动态规划

继续优化：这个for循环枚举行为真的有必要吗？

**斜率优化：**

![1674624999666](algorithm.assets/1674624999666.png)

我们发现2，6依赖的位置和3，6依赖的位置有重复，说明，2，6的位置只需要把3，6的值+2，4的值即可

![1674625633940](algorithm.assets/1674625633940.png)

----

### 二叉树递归套路：左树信息和右树信息加工出自己信息

![1674625831838](algorithm.assets/1674625831838.png)

满足这种最大拓扑结构的有多少个节点

![1674626156324](algorithm.assets/1674626156324.png)

例如这棵树，以5作为拓扑结构的头节点的情况下，满足搜索二叉树的就是右边这样，然后我们可以生成一些数据，比如6这个点，他的左子树和右子树都为这个拓扑结构提供了0个节点，而3的右子树为这个结构提供了1个节点

**这些叫作 拓扑贡献记录 ，这些记录都对5这个点负责**

![1674626332384](algorithm.assets/1674626332384.png)

现在我们有x节点，我们求出他的左树的拓扑结构，让他对他的左子树负责，然后同理求右子树的，如果这个过程很快，那么我们可以很快将左右子树的贡献记录更新到x节点上

![1674626606154](algorithm.assets/1674626606154.png)

如何把10的贡献记录更新给18，就是看10节点的右子树，一直往下看，如果全都小于18，那就可以全部更新，如果遇到大于18的，就删掉那一部分，然后往上重新更新

而如果是看右树，就是看右树的所有左边界

每一个节点都生成相应拓扑结构的贡献记录，然后不断往上，最终能生成所有的节点的拓扑结构贡献记录，然后求全局max

时间复杂度为O(N)，因为所有节点趟左树右边界的节点都不一样，然后总共也只有O(N)，同理右树左边界一样

![1674627447444](algorithm.assets/1674627447444.png)

拓扑贡献记录 Record

![1674627480232](algorithm.assets/1674627480232.png)

![1674627513436](algorithm.assets/1674627513436.png)

----

### 完美洗牌问题

![1674627822338](algorithm.assets/1674627822338.png)

这个问题实际上需要问的是原地调整，额外空间复杂度O(1)，这题实际时间复杂度是O(Nlog3N)

![1674628116471](algorithm.assets/1674628116471.png)

我们直接可以用公式得到左边部分和右边部分需要去的位置在哪里(这里规定了i从1开始)

我们可以尝试从1开始不断循环转换，比如1应该放到2位置，然后2就放到4位置，4又回过头来放回到1位置，这样循环放，虽然看起来不错，但是可能会遇到循环不完的情况

这其实就是，在一个数组中，可能有很多个小环可以来循环，每个小环是不相交的，那么我们就可以去寻找一个方法找到每一个环的起点，然后去做循环交换

![1674628545220](algorithm.assets/1674628545220.png)

**结论就是，当这个N是3^k-1时，即N=2，8，26....时，不同环的出发点是1，3，9...3^(k-1)**，这些点做下标的循环交换就可以完美洗牌

那么我们如何看普通偶数呢？

首先了解一个算法原型：

![1674628765356](algorithm.assets/1674628765356.png)

**如果一个数组，要求把两边部分交换，额外空间复杂度为O(1)，那么我们可以先把左边双指针逆序，然后右边再逆序，然后整体再逆序，就成功了**

![1674628936757](algorithm.assets/1674628936757.png)

假设N=14的情况，我们找到一个3^k-1，最接近14但是不大于14的，就是8，那么我们就先构建出8个的

![1674629095881](algorithm.assets/1674629095881.png)

那么我们发现，可以让L5L6L7这个左边部分和R1R2R3R4这个右边部分交换，得到了下面这个8个数，然后我们再用刚才的结论，8个数可以知道出发点是1和3，就可以得到结果的前部分

然后再把右边重复一遍操作，右边还剩6个数，不大于6的3^k-1就是2，那么就让L5先和R5在一起，就开始交换，不断重复

其实就是把普通的偶数，不断划分为3^k-1次方的块

![1674629304371](algorithm.assets/1674629304371.png)

![1674629338728](algorithm.assets/1674629338728.png)

![1674629353958](algorithm.assets/1674629353958.png)

----



加题：一个无序数组，需要调整成a<=b>=c<=d>=e.....，额外空间复杂度为O(1)，数组长度奇偶随意

![1674629592914](algorithm.assets/1674629592914.png)

如果数组长度为偶数：

第一步，先把数组排序，必须用堆排序，因为快排额外空间复杂度O(logN)，归并O(logN)

![1674629729818](algorithm.assets/1674629729818.png)

第二步，完美洗牌

第三步，交换

如果数组长度为奇数：

第一步排序，第二步，不动L0，把后面部分完美洗牌

![1674629837811](algorithm.assets/1674629837811.png)

----

### 从左往右尝试模型

![1674632073801](algorithm.assets/1674632073801.png)

？就是说，可以替代任意一个字符，但不能为空

*必须跟前面的字符配合使用，就是正则表达式，表示a * 可以表示0，1，2....个a

![1674633874542](algorithm.assets/1674633874542.png)

假设有.* 那么就可以替换任何东西，这里换成0个就可以跟上面相同

这题很明显是个递归行为，从左往右尝试模型，尝试过程中，每个字符都是从左往右

![1674634007449](algorithm.assets/1674634007449.png)

这个函数就是看str[si...]能否被exp[ei....]匹配出来

分情况讨论

假设后面跟的是*

![1674634580436](algorithm.assets/1674634580436.png)

那么这样的情况，就需要讨论ei+2位置往后能否匹配成功，如果后面是aab，那么ei和ei+1位置就要出3个a，如果后面是aaab，那么前面就要是2个a，这样就需要每一种可能都需要去尝试，直到成功或失败

![1674634683760](algorithm.assets/1674634683760.png)

isValid函数是用来检查有效性的，检查s是原始串，不能有符号，表达式串e，要检查 * 之前必须有字符，不能是啷个 * 挨着

**然后递归过程，要保证 ei 位置不能是*，因为不能让前面的 * 来影响后面的决定**

![1674634980402](algorithm.assets/1674634980402.png)

可能性一：没有ei + 1 位置，所以他不是 * ，或者确实不是 * 

如果当前s 已经到结尾，没字符了，表示肯定配不出来直接false

可能性二：我们看这个例子

![1677143298743](algorithm.assets/1677143298743.png)

此时进不去while循环，直接往下递归 si，ei + 2

![1677143338700](algorithm.assets/1677143338700.png)

表示前面变成0个a，用后面的去匹配

再看下面这个例子

![1677143403808](algorithm.assets/1677143403808.png)

走进while循环了，但是还是先尝试前面变成0个a，看看后面是否能匹配成功

![1677143435048](algorithm.assets/1677143435048.png)

如果走通了，直接true，否则si ++ ，表示匹配串前面变成1个a

![1677143494504](algorithm.assets/1677143494504.png)

此时继续进while循环判断，如果进不去while(表示当前字符si 和 ei 不相同)，那么就是又跳到ei + 2去匹配

因此这些情况都能够被搞定

平常改动态规划就是先把basecase填了，然后确定依赖关系，然后再改递归

但是这题不一样，因为basecase不全

![1674635585929](algorithm.assets/1674635585929.png)

填好basecase后，我们发现普遍位置，在代码中看到，调用自己的时候第一次是右下角位置，第二次是右边第二列往下所有位置

所以这个依赖关系是从右往左，从下往上

但是这样我们会发现，basecase不够，填不了最后一行，那么此时**就需要去看原题意，然后填写好一些值后再来**

我们根据依赖关系，发现至少要准备倒数两列和倒数一行的值

我们看到dp【N】【M-1】位置，发现代表的含义是，str已经没有字符了，exp串还剩一个字符，那么肯定是False

再看dp【N-1】【M-1】位置，两个都只有一个字符，只能相同才是T，再往上看，si<N-1时，ei=M-1的时候，只有ei一个字符，而str有很多字符，肯定是F

再看最后一行，str已经没有字符了，而ei可能还有几个，那么我们就可以知道，想要配出空串，只能是a * b *.....这样交替才可以让它全是0，如果是这样交替，那么就可以直接填写TF交替填，因为偶数时候才能a *为0，奇数多一个字符就只能是F

如果检测到，从哪里开始断开了a * 交替，那么后面直接为F

![1674636761009](algorithm.assets/1674636761009.png)

![1674636739845](algorithm.assets/1674636739845.png)

这个过程的代码就是这样，每次跳两个，然后看后面一个是否是 * ，如果是的话就表明可以变成空

![1674636874225](algorithm.assets/1674636874225.png)

![1674636968881](algorithm.assets/1674636968881.png)

![1674636981912](algorithm.assets/1674636981912.png)

![1674637014051](algorithm.assets/1674637014051.png)

----

### 前缀树构建贪心

![1674637065735](algorithm.assets/1674637065735.png)

先看经典暴力做法：

尝试必须以arr【i】结尾的子数组，最大异或和是多少，尝试所有 i 

![1674645999211](algorithm.assets/1674645999211.png)

优化版本：

s-i 的异或和，其实等于0-i 的异或和，异或上 0-s-1的异或和

![1674646895090](algorithm.assets/1674646895090.png)

先得到一个异或和数组，然后去求解，消除一个枚举行为

再优化：通过前缀树

![1674647202380](algorithm.assets/1674647202380.png)

这些是0-i 的异或和，最后0-5的异或和是0110，然后就看，0110和谁结合得到的值是最大的

接下来我们把这些值，用**前缀树的方式组织，然后来构建贪心**

![1674647429178](algorithm.assets/1674647429178.png)

我们可以看到，我们要求的是，0-5的异或和即0110和谁结合能得到最大，那么就可以从高位开始贪心，第一位是0，那么我们就走1，第二位是1，那么我们就走0，第三位想要0，但是只有1，继续走完就得到结果了

![1674647704069](algorithm.assets/1674647704069.png)

这是前缀树，只有两条路，走向0的路和走向1的路

![1674647758607](algorithm.assets/1674647758607.png)

这里面先初始化前缀树后，sum就是0-i 的异或和，然后maxXor方法是求得0-i 和谁异或得到的最大异或和

![1674648093005](algorithm.assets/1674648093005.png)

这个是前缀树的建立，add方法中，move是向右位移多少位，因为一个数有32位，把每一位取出来，这个path就是取得的0或者1，然后建立前缀树，如果有节点那就保持，没有就新建

**之前讲解的例子是无符号的，现在遇到有符号的其实也是差不多，符号位保持变为正数就好，0正1负**

不是符号位的其他位置，那就是希望遇到和当前状态不一样的状态

![1674648412664](algorithm.assets/1674648412664.png)

res |=这句话，就是让num的第move位和实际走的路进行异或后得到的结果向左位移move位置，然后用res去进行或运算，就把这个状态放到res的move位置了

----

### 尝试

![1674651595224](algorithm.assets/1674651595224.png)

就是如果打爆X，那么分数就是距离X左边最近的没爆的气球的分数 * X的分数 * 距离X右边最近没爆的气球i的分数

![1674651757414](algorithm.assets/1674651757414.png)

如果左侧没有气球，就可以认为左侧气球分数为1，右侧同理

![1674653827215](algorithm.assets/1674653827215.png)

我们先尝试，所有气球最先打爆，发现参数不够，需要依赖左边和右边的分数

所以考虑每个气球最后打爆

![1674654097480](algorithm.assets/1674654097480.png)

我们可以发现，这个函数上潜台词，L-1和R+1肯定没爆

所以第一次是f(1，6)

第一种，1号位置是最后爆，那么最后就是f(2，6) +1 * 3 * 1

第二种，6最后爆，那么就是f(1，5)+1 * 2 * 1

第三种，2号位置最后爆，那么就是f(1,1)+f(3，6) + 1 * 2 * 1

.....

![1674654398056](algorithm.assets/1674654398056.png)

将数组处理一下，最前和最后添1

![1674654611719](algorithm.assets/1674654611719.png)

然后自己改动态规划就行，这题发现无法斜率优化

----

尝试

![1674654714063](algorithm.assets/1674654714063.png)

![1674656517342](algorithm.assets/1674656517342.png)

三步走N层汉诺塔，等比数列的规模，所以一定会走(2^N)-1步

现在开始，我们要忘掉左中右，只看from，to，other

![1674656750821](algorithm.assets/1674656750821.png)

![1674656848587](algorithm.assets/1674656848587.png)

主函数就是从1-3，中间状态是2

然后我们发现，3个步骤里面，没有一个步骤是 i 需要到达 other状态的，所以遇到这种情况直接返回-1

![1674656995662](algorithm.assets/1674656995662.png)

如果 i 已经在to位置上了，则步数就取决于第三大步骤的完成程度了

1<<i 就是指 2^i 次方，因为0-i 有i+1个数，所以2^(i+1-1)

结果就是1和2两大步骤的步数+第三步骤完成的程度，O(N)

递归改迭代

![1674657129892](algorithm.assets/1674657129892.png)

![1674657136009](algorithm.assets/1674657136009.png)

----

还是范围尝试

![1674711095014](algorithm.assets/1674711095014.png)

![1674711217933](algorithm.assets/1674711217933.png)

假设让第一种结构的第一组兄弟和第三组兄弟组内交换，那么就可以得到它的旋变串bdca

每一组都有很多个兄弟组，可以选择任意组兄弟组进行交换，然后得到旋变串

题意就是给出两个字符串，判断是否为兄弟串

![1674711722752](algorithm.assets/1674711722752.png)

我们发现，就算过滤器过滤掉了长度和字符种类数量不同的结果，剩下的也不一定都是旋变串，那么开始讨论范围上

但是这样就有4个可变参数，但是我们可以确定，L1-R1和L2-R2一定长度相等，因为不相等肯定不是旋变串，那么就可以考虑减少一维

![1674711799319](algorithm.assets/1674711799319.png)

接下来看可能性分类：

![1674711959719](algorithm.assets/1674711959719.png)

假设是k=5，那么我们开始切分，假设第一刀切出来是左边为1右边为4，那么就有两种可能

第一种，a1=b1 && a2-a5与b2-b5互为旋变串（第一刀切了后不交换）

第二种，a1和b5 && a2-a5与b1-b4（第一刀切了后要交换）

两种可能一种为true则整体就是互为旋变串

然后就是不断增大一刀切的两部分左边的长度，也是分为交换和不交换来考虑

![1674712175049](algorithm.assets/1674712175049.png)

![1674712206900](algorithm.assets/1674712206900.png)

这个方法是大过滤器检查字符种类和数量

![1674712225857](algorithm.assets/1674712225857.png)

![1674712279249](algorithm.assets/1674712279249.png)

我们发现，当size=1的时候，直接就是basecase可以填完第一层的正方形内容，然后下面递归过程可以看出来，size都是在变小，所以只依赖的下一层的值，所以从第一层往上填即可

![1674713958094](algorithm.assets/1674713958094.png)

但是这个代码有问题，因为三维表里面，有些位置是用不到的

比如L1和L2已经到了6了，N=8，那么size就不能是8了，直接跑这个代码会越界

L1+size<=N，保证L1后面才能有size个，所以L1<=N-size

不是这道题这样看，每道题都要考虑到这种情况

![1674714276851](algorithm.assets/1674714276851.png)

**考虑到递归的某些情况是用不到的，那么填表的时候也不能填**

----

### 滑动窗口

![1674714599770](algorithm.assets/1674714599770.png)

做一个map，记录还欠了多少个对应字符，用一个变量all记录总共欠多少个字符

然后滑动窗口开始做，直到all=0，这里表示0位置开头到6位置才能刚好满足结果

![1674714932883](algorithm.assets/1674714932883.png)

然后我们开始缩短窗口，L向右移动，发现移动两个后，all还是0，所以满足的结果长度从7减小到5

![1674715037276](algorithm.assets/1674715037276.png)

然后继续往右缩短，发现a=1.all=1，那么就让R向右移动继续调整，最终每个字符开头的结果都可以求出来，找最小即可

----

### LFU缓存替换算法，二维双向链表

LeetCode Hard难度的LFU

![1674715156990](algorithm.assets/1674715156990.png)

![1674715414338](algorithm.assets/1674715414338.png)

假设有个黑盒，记录的是key，value，操作次数，最近操作时间点

假设这个黑盒只能存3条记录，此时多来了一个新记录，那么第一个策略是替换掉次数最少的，如果次数相同，那么就替换掉时间点更早的

求这个黑盒方法怎么实现，get和set操作的时间复杂度要是O(1)

O(1)表示，遍历不行，有序表不行(复杂度为O(logN))，所以需要使用**二维双向链表**

![1674715742339](algorithm.assets/1674715742339.png)

首先进来一个A，那么我们将其放入到词频为1的桶里面，桶里是个双向链表，然后有个map，里面记录了key对应的节点的内存地址，然后来了B后，把A的尾部节点挂上B，整个桶只记录头尾，所以可以直接挂到尾部，如果get了一次B，那么B的词频变为2了，所以B在1中直接断掉，然后取出来发现没有词频为2的桶，所以新建一个词频为2的桶，然后桶1和桶2之间也是双向链表链接，这样构成的二维双向链表

如果桶里面没有了，那么就直接销毁掉，这样我们的更新操作都是O(1)，有就放进去，没有就新建桶

但是麻烦点就在于桶的消除和节点的重连的coding

----



![1674716100739](algorithm.assets/1674716100739.png)

![1674716244599](algorithm.assets/1674716244599.png)

油数组代表每个加油站有多少油，距离数组代表，0位置就是代表0-1的距离是4，1位置代表1号位置到2号位置距离为1

问题是那些加油站可以从自己出发转一圈，假设油箱是无限大

结果要求生成一个布尔类型数组，表示每个点是否能够从自己出发转一圈

整个过程O(N)，额外空间复杂度O(1)的解：

首先我们将油数组变换为纯能值数组：纯能值=油-距离，我们这样是为了省空间，因为我们可以再变换回油数组

这样整个题就变成了沿途的累加和是否小于零了，小于零就跑不完

![1674717503369](algorithm.assets/1674717503369.png)

做出一个连通区，左闭右开，假设从H开始，先逆时针扩展，此时连通区是H,T，即只包含H点，选择H点是因为他是正数，满足开始要求，则我们的rest=5，然后逆时针看T点是-4，rest>-4，满足要求扩展到 [H，A)，然后rest-=-4，rest=1，继续扩展看A，发现-2>1，所以表示H点不符合要求，那么向左开始拓展，看到G点是2，所以可以拓展成[G，A)，此时rest+=G点上的2，即rest=3，此时满足A点要求，拓展到[G,B)，rest-=A点上的2，所以rest=1，发现B为正数，继续拓展到[G，C)，此时rest=1+1=2，C点不行，所以G点不是良好出发点，然后往左看，F点不满组接入连通区的要求即正数，所以F点不是良好出发点，同时，need+=F点上的2，E点同理，need+=1，need=3，表示下一个点想要接入，首先需要把need清空，发现D点可以，此时need清空为0，然后接入区[D，C)，此时rest=2，发现还是C点不行，此时发现已经越界，表示整个环都不行

----



![1674738400257](algorithm.assets/1674738400257.png)

**一个正确的搜索二叉树，得到的中序遍历结果应该是升序的**

![1674740052529](algorithm.assets/1674740052529.png)

我们只需要找第一次发生降序的前一个和第二次发生降序的后一个

进阶：只有两个节点错误才调整，多个节点或者没有错误就不调整

那么我们只需要看是否多次降序，超过2次则表明一定多于2个，但是如果只有一次降序，并不代表就只有一个节点错误了

![1674740767298](algorithm.assets/1674740767298.png)

那么其实也就是我们可以先让4和2交换，然后看整个序列是否升序，如果升序则表明确实只有2个节点错误，如果不是则表明多余两个节点错误

再进阶：虽然在刷题上看，交换值可以解决，但是工作上，不一定能够交换值，或者有多个机器的情况，那么我们就需要交换这个结构

![1674741288188](algorithm.assets/1674741288188.png)

![1674741301378](algorithm.assets/1674741301378.png)

![1674741310477](algorithm.assets/1674741310477.png)

![1674741320179](algorithm.assets/1674741320179.png)

----



![1674741342631](algorithm.assets/1674741342631.png)

