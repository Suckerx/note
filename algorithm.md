## 认识复杂度和简单排序算法

![1666078028807](algorithm.assets/1666078028807.png)

**冒泡排序：**

比较0 和 1 位置上的数大小，然后交换，然后比较1 和 2 位置上的数交换，依次类推，第二遍从1 开始，1 和 2 比较后交换

![1666081093445](algorithm.assets/1666081093445.png)

因此是等差数列，时间复杂度为O(n^2)

![1666081184424](algorithm.assets/1666081184424.png)

代码：

![1666081288048](algorithm.assets/1666081288048.png)

异或运算：相同为0，不同为1，或者理解为不进位相加

![1666081407183](algorithm.assets/1666081407183.png)

不开辟额外空间交换两个数，**但是要保证a和b指向的内存不同**，因此在上面那个方法中，**i一定不能等于j**

![1666081570256](algorithm.assets/1666081570256.png)

**面试题：在一堆数中，有一个数出现了奇数次，其他数都出现了偶数次，找出这个奇数次的数**

![1666081981177](algorithm.assets/1666081981177.png)

思路：使用异或运算，每个数都跟eor异或，最终得到就是那个奇数次的数

![1666082020110](algorithm.assets/1666082020110.png)

**面试题：在一堆数中，有两个数出现了奇数次，其他数都出现了偶数次，找出这两个奇数次的数**

![1666083510316](algorithm.assets/1666083510316.png)

在一堆数中进行异或，最终结果就是a^b，他们肯定不等于0，表示a和b用二进制表示至少有一位是1，即有一个位置a和b不相同，假设为第8位，根据这个第8位将原数组进行分类，分为第8位是1的数和第8位是0的数，而a和b只可能分别在两边，此时用一个变量去异或第8位是1的数，此时这个变量一定是a或者b，再让他和eor进行异或，即可得到另一个数

提取一个数最右侧的1：

![1666084222500](algorithm.assets/1666084222500.png)

![1666084231117](algorithm.assets/1666084231117.png)



![1666084329319](algorithm.assets/1666084329319.png)

**插入排序**

![1666084393362](algorithm.assets/1666084393362.png)

![1666085142768](algorithm.assets/1666085142768.png)

一直往前面比较，直到比前面大就结束

**二分法**

![1666085341263](algorithm.assets/1666085341263.png)

局部最小值就是 i 位置的数要小于其左右两边的数，求局部最小值也可以用二分

**对数器**

![1666096804589](algorithm.assets/1666096804589.png)

随机数组方法

![1666097147483](algorithm.assets/1666097147483.png)

![1666097181979](algorithm.assets/1666097181979.png)

## 认识O(NlogN)的排序

**递归**

![1666098253661](algorithm.assets/1666098253661.png)

 求中点位置防止溢出：右移一位

![1666098374004](algorithm.assets/1666098374004.png)

![1666098429150](algorithm.assets/1666098429150.png)

master 公式的介绍：

母问题N个数据，子问题每次都是 N/b 的规模，a指的是子问题调用次数，后面的是除了子问题外剩下过程的时间复杂度

![1666099083933](algorithm.assets/1666099083933.png)

所以求出来是这样

![1666100229210](algorithm.assets/1666100229210.png)

